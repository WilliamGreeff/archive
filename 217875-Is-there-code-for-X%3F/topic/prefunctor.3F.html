---
layout: archive
title: Zulip Chat Archive
permalink: /stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/index.html">Is there code for X?</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html">prefunctor?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209886466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886466">(Sep 12 2020 at 15:41)</a>:</h4>
<p>I don't know what this is actually called....</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">prefunctor</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_hom</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_hom</span> <span class="n">D</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span>
<span class="o">(</span><span class="n">map</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">obj</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">obj</span> <span class="n">Y</span><span class="o">))</span>
</code></pre></div>


<p>Does this exist somewhere in mathlib?</p>



<a name="209886531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886531">(Sep 12 2020 at 15:42)</a>:</h4>
<p>it's like <code>functor</code> (the <code>_root_</code> one)</p>



<a name="209886547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886547">(Sep 12 2020 at 15:42)</a>:</h4>
<p>Right, I know that. But I would like to use it with <code>has_hom</code>, as above.</p>



<a name="209886570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886570">(Sep 12 2020 at 15:43)</a>:</h4>
<p>I'm building the free category associated to a type <code>C</code> with a <code>has_hom</code> instance, and this is what is needed to state its universal property.</p>



<a name="209886778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886778">(Sep 12 2020 at 15:48)</a>:</h4>
<p>it probably doesn't exist (otherwise <code>functor</code> would have depended on it)</p>



<a name="209886800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886800">(Sep 12 2020 at 15:49)</a>:</h4>
<p>I was at one point meaning to give this the perhaps controversial name of "diagram"</p>



<a name="209886860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886860">(Sep 12 2020 at 15:50)</a>:</h4>
<p>These things do actually show up in math. One thing I know about specifically is in defining Nori's version of the motivic Galois group, and he does indeed call them "diagrams"</p>



<a name="209886951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886951">(Sep 12 2020 at 15:52)</a>:</h4>
<p>"pregraph" also makes sense for a name.</p>



<a name="209886976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886976">(Sep 12 2020 at 15:53)</a>:</h4>
<p>Anyway, in case anyone is interested:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/free_cat/src/category_theory/category/free.lean">https://github.com/leanprover-community/mathlib/blob/free_cat/src/category_theory/category/free.lean</a></p>



<a name="209886985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209886985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209886985">(Sep 12 2020 at 15:53)</a>:</h4>
<p>You can also define what it means to be the (co)limit of one of these things--having a functor and, in particular, a domain <em>category</em> isn't necessary, and not always convenient. (I guess this is to some extent related to wanting to use these things to talk about free categories.)</p>



<a name="209887027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887027">(Sep 12 2020 at 15:54)</a>:</h4>
<p>Right.</p>



<a name="209887042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887042">(Sep 12 2020 at 15:54)</a>:</h4>
<p>e.g. a pushout is a colimit of a diagram indexed on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo><mo>←</mo><mo>⋅</mo><mo>→</mo><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot \leftarrow \cdot \to \cdot</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span></span></span></span>, with no category structure implied &amp; therefore no identity morphisms</p>



<a name="209887053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887053">(Sep 12 2020 at 15:55)</a>:</h4>
<p>so in that context, the name diagram makes some sense.</p>



<a name="209887255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209887255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209887255">(Sep 12 2020 at 15:57)</a>:</h4>
<p>Yeah I agree. A guess a lot of the stuff in the <code>shapes</code> dir can be made into diagrams (or free categories associated with a diagram).</p>



<a name="209889547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889547">(Sep 12 2020 at 16:46)</a>:</h4>
<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class="user-mention" data-user-id="110032">@Reid Barton</span></p>



<a name="209889556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889556">(Sep 12 2020 at 16:47)</a>:</h4>
<p>nope</p>



<a name="209889842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889842">(Sep 12 2020 at 16:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209889547">said</a>:</p>
<blockquote>
<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class="user-mention silent" data-user-id="110032">Reid Barton</span></p>
</blockquote>
<p>On the "unrelated" topic -- I recently did something with those given I wanted to keep using vim for lean -- the most straightforward way for all the unicode stuff without getting too far inside the lean LSP was I basically used the translations.json file from the lean vscode extension and autogenerated snippets from it for vim to use, which I put here: <a href="https://github.com/Julian/lean-unicode.vim/blob/main/Ultisnips/lean.snippets">https://github.com/Julian/lean-unicode.vim/blob/main/Ultisnips/lean.snippets</a> -- presuming emacs has a way to load ultisnips formatted snippets that may already be usable exactly as is)</p>



<a name="209889897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209889897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209889897">(Sep 12 2020 at 16:54)</a>:</h4>
<p>Yeah I guess I can do something with <code>yasnippet</code> (the canonocal(?) snippet package in emacs)</p>



<a name="209890071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209890071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209890071">(Sep 12 2020 at 16:58)</a>:</h4>
<p>Okay, that works. I just made a snippet file for <code>yasnippet</code> that looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span> <span class="n">key</span><span class="o">:</span> <span class="n">funct</span>
<span class="bp">#</span> <span class="n">name</span><span class="o">:</span> <span class="n">func_symb</span>
<span class="bp">#</span> <span class="c1">--</span>
<span class="err">⥤$</span><span class="mi">0</span>
</code></pre></div>



<a name="209896928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209896928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209896928">(Sep 12 2020 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209889547">said</a>:</p>
<blockquote>
<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class="user-mention silent" data-user-id="110032">Reid Barton</span></p>
</blockquote>
<p>I think we might be allowed to add it to <code>lean-mode</code>.  All the input translations are defined by <code>lean-input-translations</code> in <a href="https://github.com/leanprover/lean-mode/blob/master/lean-input.el">https://github.com/leanprover/lean-mode/blob/master/lean-input.el</a>  (though if you want to experiment locally, you can customize <code>lean-input-user-translations</code>)</p>
<p>Does VSCode already have a way to input the category theory functor symbol?  If not, maybe <code>\Functor</code> (vs <code>\functor</code>)?</p>



<a name="209897607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Peattie <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897607">(Sep 12 2020 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209896928">said</a>:</p>
<blockquote>
<p>Does VSCode already have a way to input the category theory functor symbol?  If not, maybe <code>\Functor</code> (vs <code>\functor</code>)?</p>
</blockquote>
<p>Yeah it's <code>\functor</code> currently (<a href="https://github.com/leanprover/vscode-lean/blob/v0.16.13/translations.json#L1075">source</a>)</p>



<a name="209897659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Peattie <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897659">(Sep 12 2020 at 20:06)</a>:</h4>
<p>oh sorry, I misunderstood <code>\functor</code> is mapped to ⥤</p>



<a name="209897852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897852">(Sep 12 2020 at 20:11)</a>:</h4>
<p>I think \func suffices in vscode.</p>



<a name="209897896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897896">(Sep 12 2020 at 20:12)</a>:</h4>
<p>Actually, that's useful to know.  It seems like <code>\functor</code> in VSCode is <code>⥤</code> and <code>\Rightarrow</code> is <code>⇒</code>, where in emacs <code>\functor</code> and various other options give only <code>⇒</code>.</p>



<a name="209897902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209897902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209897902">(Sep 12 2020 at 20:12)</a>:</h4>
<p>I wouldn't mind if <code>\functor</code> in emacs were <code>⥤</code></p>



<a name="209898224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898224">(Sep 12 2020 at 20:21)</a>:</h4>
<p>Ok, here's a PR: <a href="https://github.com/leanprover/lean-mode/pull/29">https://github.com/leanprover/lean-mode/pull/29</a></p>



<a name="209898298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898298">(Sep 12 2020 at 20:23)</a>:</h4>
<p>Does the melpa package mirror this?</p>



<a name="209898385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898385">(Sep 12 2020 at 20:25)</a>:</h4>
<p>I don't know how it works, other than changes I've made in the past eventually appear in melpa</p>



<a name="209898393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898393">(Sep 12 2020 at 20:25)</a>:</h4>
<p>Ok cool</p>



<a name="209898407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898407">(Sep 12 2020 at 20:26)</a>:</h4>
<p>I look forward to this getting merged!</p>



<a name="209898462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898462">(Sep 12 2020 at 20:26)</a>:</h4>
<p>If there are other missing symbols, this might be a good time to add them</p>



<a name="209898527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898527">(Sep 12 2020 at 20:28)</a>:</h4>
<p>That's the main one I've been frustrated with. Maybe <span class="user-mention" data-user-id="110032">@Reid Barton</span> has others he would like to see?</p>



<a name="209898532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209898532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209898532">(Sep 12 2020 at 20:28)</a>:</h4>
<p>Nothing else comes to mind</p>



<a name="209903664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209903664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209903664">(Sep 12 2020 at 23:01)</a>:</h4>
<p>Refactoring <code>functor</code> to use <code>prefunctor</code> (I like <code>diagram</code>!) sounds like a great idea.</p>



<a name="209905117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209905117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209905117">(Sep 12 2020 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209903664">said</a>:</p>
<blockquote>
<p>Refactoring <code>functor</code> to use <code>prefunctor</code> (I like <code>diagram</code>!) sounds like a great idea.</p>
</blockquote>
<p>I agree. The question is how to do it. Note that to define a sufficiently nontrivial notion of a morphism between <code>prefunctor</code>s, you need to make some sort of <code>has_comp</code> class (in order to state the naturality condition).</p>



<a name="209905932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209905932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209905932">(Sep 13 2020 at 00:06)</a>:</h4>
<p>Isn't <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.category_struct/src">src#category_theory.category_struct</a> all that we need?</p>



<a name="209906341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209906341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209906341">(Sep 13 2020 at 00:19)</a>:</h4>
<p>Oh right. And that also allows us to define an "indentity" morphism.</p>



<a name="209955189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209955189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209955189">(Sep 13 2020 at 23:54)</a>:</h4>
<p>you guys can use <code>func</code> for <code>⥤</code> in Emacs by adding the following snippet as part of your <code>lean-mode-hook</code>:</p>
<div class="codehilite"><pre><span></span><code>  <span class="p">(</span><span class="nv">lean-input-incorporate-changed-setting</span>
   <span class="ss">&#39;lean-input-user-translations</span>
   <span class="o">`</span><span class="p">(</span> <span class="p">(</span><span class="s">&quot;func&quot;</span> <span class="s">&quot;⥤&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="s">&quot;tf&quot;</span> <span class="s">&quot;⟨╯°□°⟩╯︵┻━┻&quot;</span><span class="p">)</span>
<span class="p">))</span>
</code></pre></div>



<a name="209955981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209955981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209955981">(Sep 14 2020 at 00:18)</a>:</h4>
<p>tf?</p>



<a name="209956372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/209956372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#209956372">(Sep 14 2020 at 00:28)</a>:</h4>
<p>It must be the little-used principle of <em>tabula furorem</em></p>



<a name="211927329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927329">(Oct 01 2020 at 15:23)</a>:</h4>
<p>Did you make any progress on <code>prefunctor</code> / <code>diagram</code>, <span class="user-mention" data-user-id="243562">@Adam Topaz</span>? We'll soon have three copies of the <code>lift</code>/ <code>ι</code> relationship ((<code>free</code>|<code>exterior</code>|<code>universal_enveloping</code>) <code>_algebra</code>), and I was looking at adding <code>clifford_algebra</code> too...</p>



<a name="211927376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927376">(Oct 01 2020 at 15:23)</a>:</h4>
<p>Sorry, I've been busy with teaching :(</p>



<a name="211927569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927569">(Oct 01 2020 at 15:24)</a>:</h4>
<p>But I'm not sure the <code>lift</code> / <code>\iota</code> stuff really relates to this.</p>



<a name="211927801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211927801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211927801">(Oct 01 2020 at 15:26)</a>:</h4>
<p>How would you like to use these <code>diagram</code>s in this context?</p>



<a name="211928281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211928281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211928281">(Oct 01 2020 at 15:29)</a>:</h4>
<p>You said yourself you wanted to use it to state the universal property, and I think somehow I saw a connection - but I can't see it any more.</p>



<a name="211928526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211928526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211928526">(Oct 01 2020 at 15:31)</a>:</h4>
<p>Oh, I was referring to the universal property specifically for the free category associated to a <code>diagram</code>.</p>



<a name="211928555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211928555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211928555">(Oct 01 2020 at 15:31)</a>:</h4>
<p>the analogue of <code>\iota</code> in that case is a <code>prefunctor</code>.</p>



<a name="211929072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211929072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211929072">(Oct 01 2020 at 15:34)</a>:</h4>
<p>I think I was hoping for a bundling of <code>lift</code> and  <code>ι</code>, so that we can state the theorems about the bundle in just one place rather than repeating them</p>



<a name="211952981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211952981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211952981">(Oct 01 2020 at 18:24)</a>:</h4>
<p>The bundle of <code>lift</code> and <code>\iota</code> in this case just means that you have an initial object in some category, and initial objects are in mathlib already. But I don't necessarily think that's a more useful description than just keeping <code>lift</code> and <code>\iota</code> around as is.</p>



<a name="211955224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211955224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211955224">(Oct 01 2020 at 18:40)</a>:</h4>
<p>(deleted)</p>



<a name="211990000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211990000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211990000">(Oct 01 2020 at 23:50)</a>:</h4>
<p>My preference would be for adding <em>in addition</em> to the existing <code>lift</code> and <code>\iota</code> the formulation as an initial object.</p>



<a name="211990031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211990031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211990031">(Oct 01 2020 at 23:51)</a>:</h4>
<p>In practice one is usually happy to use the explicit <code>lift</code> and <code>\iota</code> in most places. But it is a nice verification that we've really stated the right properties to have the initial object formulation.</p>



<a name="211992673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211992673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211992673">(Oct 02 2020 at 00:33)</a>:</h4>
<p>I agree with this. But the examples <span class="user-mention" data-user-id="310045">@Eric Wieser</span> mentioned are all left adjoints. I presume a better route would be to prove the adjunction <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="211993171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993171">(Oct 02 2020 at 00:41)</a>:</h4>
<p>Some other category libraries have a notion like "something determined by a universal property", generally an initial/terminal object of a comma category, I think. Then this can be used to define limits and maybe adjunctions and so on.</p>



<a name="211993226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993226">(Oct 02 2020 at 00:42)</a>:</h4>
<p>I think it's the kind of concept that in informal mathematics we can recognize but don't really have a name for.</p>



<a name="211993234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993234">(Oct 02 2020 at 00:42)</a>:</h4>
<p>Because it is too basic/central somehow.</p>



<a name="211993241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993241">(Oct 02 2020 at 00:43)</a>:</h4>
<p>Do you have an example of such a library in mind?</p>



<a name="211993274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993274">(Oct 02 2020 at 00:43)</a>:</h4>
<p>Could this be a replacement for, e.g.  the localization stuff?</p>



<a name="211993322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993322">(Oct 02 2020 at 00:44)</a>:</h4>
<p>e.g. <a href="https://github.com/HoTT/HoTT/blob/master/theories/Categories/KanExtensions/Core.v#L167-L168">https://github.com/HoTT/HoTT/blob/master/theories/Categories/KanExtensions/Core.v#L167-L168</a></p>



<a name="211993346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993346">(Oct 02 2020 at 00:45)</a>:</h4>
<p><a href="https://github.com/HoTT/HoTT/blob/master/theories/Categories/UniversalProperties.v#L68-L69">https://github.com/HoTT/HoTT/blob/master/theories/Categories/UniversalProperties.v#L68-L69</a></p>



<a name="211993383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993383">(Oct 02 2020 at 00:46)</a>:</h4>
<p><a href="https://github.com/HoTT/HoTT/blob/092ebba509710c6e3eadbe03bc68049dd0b4ea0c/theories/Categories/Category/Objects.v#L36-L37">https://github.com/HoTT/HoTT/blob/092ebba509710c6e3eadbe03bc68049dd0b4ea0c/theories/Categories/Category/Objects.v#L36-L37</a></p>



<a name="211993440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993440">(Oct 02 2020 at 00:46)</a>:</h4>
<p><a href="https://github.com/HoTT/HoTT/blob/master/theories/Categories/Limits/Core.v#L107-L108">https://github.com/HoTT/HoTT/blob/master/theories/Categories/Limits/Core.v#L107-L108</a></p>



<a name="211993613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993613">(Oct 02 2020 at 00:50)</a>:</h4>
<p>Is this definition of initial objects correct? is the empty type contractible (in HoTT)?</p>



<a name="211993639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993639">(Oct 02 2020 at 00:51)</a>:</h4>
<p>It's the homsets out that are contractible</p>



<a name="211993648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993648">(Oct 02 2020 at 00:51)</a>:</h4>
<p>Oh right</p>



<a name="211993727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993727">(Oct 02 2020 at 00:53)</a>:</h4>
<p>wait I mean what happens if there are no morphisms from x to x'?</p>



<a name="211993741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993741">(Oct 02 2020 at 00:53)</a>:</h4>
<p>The empty type is not contractible</p>



<a name="211993782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993782">(Oct 02 2020 at 00:54)</a>:</h4>
<p>(whoops internet is flaky in that room)</p>



<a name="211993900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993900">(Oct 02 2020 at 00:57)</a>:</h4>
<p>I think one version of this concept is as follows. Sometimes, you have a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">U : D \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> which doesn't necessarily have a left adjoint but for some particular <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X \in C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, you can still find an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>X</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">FX \in D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> such that for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> there's an iso <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>F</mi><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>U</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Hom}(FX, Y) = \mathrm{Hom}(X, UY)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>.</p>



<a name="211993960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211993960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211993960">(Oct 02 2020 at 00:58)</a>:</h4>
<p>for example, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mi>I</mi></msup></mrow><annotation encoding="application/x-tex">U : C \to C^I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span></span></span></span></span></span></span> could be the diagonal functor and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">FX</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> the colimit of a specific diagram <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X : I \to C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p>



<a name="211994066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994066">(Oct 02 2020 at 01:00)</a>:</h4>
<p>We have the notion of a colimit of a specific diagram, and we know (I guess, or could easily add) that the whole colimit <em>functor</em> is adjoint to the diagonal functor when it exists, but AFAIK we don't have a way to say how an individual colimit is related to the diagonal functor.</p>



<a name="211994109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994109">(Oct 02 2020 at 01:01)</a>:</h4>
<p>You can probably do something with cones</p>



<a name="211994191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994191">(Oct 02 2020 at 01:03)</a>:</h4>
<p>The cone category we have is basically a one-off construction of the comma category of the diagonal functor.</p>



<a name="211994285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994285">(Oct 02 2020 at 01:04)</a>:</h4>
<p>whereas those HoTT library snippets I linked to build it up incrementally</p>



<a name="211994290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994290">(Oct 02 2020 at 01:04)</a>:</h4>
<p>I have no idea how well that works for usability, of course</p>



<a name="211994417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211994417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211994417">(Oct 02 2020 at 01:07)</a>:</h4>
<p>For localization (of a ring, say, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[S^{-1}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>) you could look for an initial object of the full subcategory of the slice category consisting of the guys where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> gets sent to invertible elements. But I don't know if it's the most convenient way to say it.</p>



<a name="211995032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211995032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211995032">(Oct 02 2020 at 01:19)</a>:</h4>
<p>I imagine there are a few styles that might possibly work, such as "every concept is an initial/terminal object in some auxiliary category", or "every concept is a Kan extension", or to do everything with profunctors and the coend calculus.</p>



<a name="211995753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211995753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211995753">(Oct 02 2020 at 01:33)</a>:</h4>
<p>None of these approaches (if implemented in lean) would solve the issue of universes when defining the universal properties, would they?</p>



<a name="211997278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/217875-Is%20there%20code%20for%20X%3F/topic/prefunctor%3F/near/211997278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/217875-Is-there-code-for-X%3F/topic/prefunctor.3F.html#211997278">(Oct 02 2020 at 02:06)</a>:</h4>
<p>I don't think so, and moreover I think this is actually a real math issue that we usually ignore (generally it's obvious once you've constructed the object that satisfies the universal property, but a priori the object could depend on the ambient universe).</p>



{% endraw %}

<hr><p>Last updated: Oct 06 2020 at 10:10 UTC</p>