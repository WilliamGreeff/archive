---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/finiteness.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html">finiteness</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="124610398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610398">(Apr 04 2018 at 06:10)</a>:</h4>
<p>Do mathlib have something that behaves like:</p>
<div class="codehilite"><pre><span></span>class  Finite (α : Type u) :=
  (cardinality : nat)
  (bijection : trunc (equiv α (fin cardinality)))
</pre></div>



<a name="124610440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610440">(Apr 04 2018 at 06:10)</a>:</h4>
<p>Is this gross for some reason, and should be avoided?</p>



<a name="124610449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610449">(Apr 04 2018 at 06:11)</a>:</h4>
<p>It is in my category theory repo (the category “set”)</p>



<a name="124610450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610450">(Apr 04 2018 at 06:11)</a>:</h4>
<p>and it’s called fintype</p>



<a name="124610479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610479">(Apr 04 2018 at 06:12)</a>:</h4>
<p>It can't be called fintype, because mathlib already has a fintype which is slightly different (but equivalent, of course).</p>



<a name="124610492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610492">(Apr 04 2018 at 06:12)</a>:</h4>
<p>I guess I'm asking if there is a strong reason to (bite the bullet and learn how to use multisets and) use mathlib's fintype, or if it's okay to use something like this.</p>



<a name="124610554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610554">(Apr 04 2018 at 06:15)</a>:</h4>
<p>oops i meant the category is called set and uses fintype</p>



<a name="124610595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610595">(Apr 04 2018 at 06:16)</a>:</h4>
<p>but I guess I didn’t notice that you used trunc</p>



<a name="124610881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610881">(Apr 04 2018 at 06:27)</a>:</h4>
<p>That's <code>fintype</code>. If you want to use such an interface to it, prove it and use it</p>



<a name="124610925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610925">(Apr 04 2018 at 06:28)</a>:</h4>
<p>Okay, I  guess that's a good point. In the meantime I'm discovering <code>fintype</code> is pretty easy to use anyway.</p>



<a name="124611257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611257">(Apr 04 2018 at 06:41)</a>:</h4>
<p>What is the lemma that says <code>fintype</code> gives <code>decidable_eq</code>?</p>



<a name="124611576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611576">(Apr 04 2018 at 06:52)</a>:</h4>
<p>I don't think it's true. So your formulation is a bit stronger, since it equips the set with a function to <code>fin</code>; in mathlib's <code>fintype</code>, this function is <code>index_of</code>, but it requires a separate proof of <code>decidable_eq</code></p>



<a name="124611584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611584">(Apr 04 2018 at 06:53)</a>:</h4>
<p>your <code>Finite</code> should be equivalent to the conjunction of <code>fintype</code> and <code>decidable_eq</code></p>



<a name="124611585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611585">(Apr 04 2018 at 06:53)</a>:</h4>
<p>ah, okay.</p>



<a name="206179081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206179081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206179081">(Aug 06 2020 at 18:29)</a>:</h4>
<p>Is there any way we could get to a world in which</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finite</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="c1">-- any definition of finiteness</span>

<span class="kn">structure</span> <span class="n">finset</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span>

<span class="n">class</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div>



<a name="206181704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206181704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206181704">(Aug 06 2020 at 18:51)</a>:</h4>
<p>cons: all <code>big_operators</code> stuff becomes noncomputable<br>
pros: API becomes comprehensible by humans, and no more instance diamonds for <code>fintype</code></p>



<a name="206182245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206182245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206182245">(Aug 06 2020 at 18:55)</a>:</h4>
<p>(I also dream of a world where <code>decidable</code>would disappear, but I know this won't happen)</p>



<a name="206182616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206182616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206182616">(Aug 06 2020 at 18:58)</a>:</h4>
<p>Up to <del>proof irrelevance</del> propositional equivalence, none of these definitions are different except you replaced <code>fintype A</code> with <code>nonempty (fintype A)</code>. Maybe we should just have a class for that, replacing <code>set.finite</code></p>



<a name="206182980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206182980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206182980">(Aug 06 2020 at 19:01)</a>:</h4>
<p>actually do we lose anything by just changing <code>fintype</code> to the nonempty version of what it currently is? <code>fintype.univ</code> becomes noncomputable but it fixes the instance diamonds</p>



<a name="206183036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183036">(Aug 06 2020 at 19:01)</a>:</h4>
<p><code>fintype.card</code> also becomes noncomputable</p>



<a name="206183487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183487">(Aug 06 2020 at 19:04)</a>:</h4>
<p>My bigger issue is that I find it really difficult to find what I'm looking for in <code>data.finset</code>/<code>data.fintype</code>/<code>data.set.finite</code>; it's possible this could be improved without any representation changes</p>



<a name="206183748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183748">(Aug 06 2020 at 19:06)</a>:</h4>
<p>But a related issue is that there are three different ways to express the same ideas and they are connected by constructions that are not that simple</p>



<a name="206183881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183881">(Aug 06 2020 at 19:07)</a>:</h4>
<p>It's my completely unsubstantiated opinion that if we proved a bunch of things for <code>finite</code>, say, we could systematically deduce the consequences for <code>finset</code> and <code>fintype</code> and end up with a more organized API</p>



<a name="206184647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206184647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206184647">(Aug 06 2020 at 19:14)</a>:</h4>
<p>Here is some pure fantasy: a universe level for only finite types</p>



<a name="206185310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206185310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206185310">(Aug 06 2020 at 19:21)</a>:</h4>
<p><code>Type (1/2:\Q)</code></p>



<a name="206211134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206211134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206211134">(Aug 06 2020 at 23:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="206214294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206214294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206214294">(Aug 07 2020 at 00:50)</a>:</h4>
<p>We must make finiteness easier for mathematicians. Counting is all over Sylow's theorems and if people can't knock them off in Lean using what we have, then I think we don't have the right things. I recently had two distinct proofs that the trivial subgroup of a group was a fintype and it was annoying.</p>



<a name="206450031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206450031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206450031">(Aug 10 2020 at 11:17)</a>:</h4>
<p>OK I have just spent some time trying to understand the issues here. I'm trying to prove Sylow's theorems with students. Sylow's theorems are theorems about finite groups with no mention of decidable equality or ever explicitly attempting to write down elements -- they apply to all finite groups. Hence it seems to me that computability is irrelevant, so <code>fintype</code> and <code>finset</code> are not the right classes. But <code>set.finite</code> isn't either, because it is unbundled finiteness. Reid is proposing a bundled version of finiteness which he also calls <code>finset</code> but how about for now we call it <code>finset2</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">finset2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>


<p>Is there an argument for developing an API for this? It is bundled noncomputable finiteness which seems to me to be the best for Lean and the best for Sylow. Have I understood things correctly? Are people just going to tell me to go ahead and try?</p>



<a name="206451212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206451212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206451212">(Aug 10 2020 at 11:36)</a>:</h4>
<p>As for cardinality some non-cardinal options would be finset2.card, <code>set.fincard : set X -&gt; nat</code> or <code>fincard : Type u -&gt; nat</code>. These are all functions we don't have, right? <span class="user-mention" data-user-id="110031">@Patrick Massot</span> you were complaining about fintype in another thread and it's got to the point where I just want to fix it. Sylow's theorems are about finite groups and I don't care whether they have decidable equality, I just want to be able to count subsets and not run into diamonds -- this is not an unreasonable request I don't think but perhaps the infrastructure is not yet there for this kind of thing.</p>



<a name="206614920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206614920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206614920">(Aug 11 2020 at 18:48)</a>:</h4>
<p>More thoughts about finiteness and cardinality for sets and types.</p>
<p>Let's start with sets. Now <code>set.finite</code> exists in mathlib already; its definition is</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>


<p>. It's not a class. Why is <code>set.finite</code> not a class? <code>is_subgroup</code> was a class. Could both <code>set.finite</code> and <code>set.infinite</code> be classes? This would be unbundled finiteness for sets (<code>normal</code> is unbundled Prop-valued normality for subgroups and we tried bundling it in the group theory game but it's quite inconvenient because you either reproduce a bunch of <code>subgroup.*</code> in <code>normal.*</code> or you put <code>to_subgroup</code> everywhere). The definition of bundled finiteness for sets I'm working with is</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finset2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">finite</span> <span class="n">S</span><span class="o">}</span>
</code></pre></div>


<p>The idea would be to develop some API for <code>set.finite</code> and encourage mathematicians who don't <code>#eval</code> to either use <code>set.finite</code> or <code>finset2</code> as their standard concept of finiteness for sets depending on whether they like bundled or unbundled -- and in particular to avoid <code>finset</code> completely because this is constructible finiteness.</p>
<p>For set cardinality the issue is that I don't know whether unbundled or bundled will be best, so I have had to introduce two nat-valued cardinalities -- firstly note that we have</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">equiv_finset</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset2</span> <span class="n">X</span> <span class="err">≃</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>


<p>and so we can define</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finset2</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">finset2</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="o">((</span><span class="n">finset2</span><span class="bp">.</span><span class="n">equiv_finset</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>
</code></pre></div>


<p>i.e. finset2.card is just finset.card but ported over the canonical bijection. This is cardinality for bundled finite sets. For unbundled finite sets there is the issue of trying to find the <code>finite</code> instance, and experience seems to show that this can be hard work, so I introduce</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sum</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span> <span class="k">then</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">f</span> <span class="k">else</span> <span class="mi">37</span>
</code></pre></div>


<p>and then define</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">set</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>


<p>These functions are really easy to apply because they don't check finiteness. Under finiteness conditions you can relate the card to finset2.card and this is your route back to finset.card if you want to port API.</p>
<p>Earlier on in my Lean career I was concerned about all this <code>noncomputable</code> stuff because I didn't really know how important computability was. The thing to understand about noncomputable cards is that you can still prove Sylow's theorems which are all about cards, you just can't <code>#eval</code>, and because I never <code>#eval</code> anyway I'm not bothered.</p>
<hr>
<p>Now onto types. For unbundled finiteness for types I'm using</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_finite</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">X</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">is_finite</span>
</code></pre></div>


<p>and again the idea is to encourage non-#eval mathematicians to use <code>is_finite</code> instead of <code>fintype</code>, because using it is strictly easier, modulo the fact that of course a whole load of the <code>fintype</code> library needs to be ported over. </p>
<p>Bundling finite types seems like the sort of thing that the category theory library might want to do, but I'm not doing it right now.</p>
<p>For cardinality again I follow the principle that the fewer inputs your function has, the easier it is to use it, so I have gone for </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">is_finite</span> <span class="n">X</span> <span class="k">then</span> <span class="bp">@</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">X</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>and of course there's a route back to fintype.card in the <code>is_finite</code> setting, which enables noncomputational API (e.g. all theorems) to be ported.</p>
<p>All this work is piling up in the group-theory-game repo because we have got to the point where we want to prove Sylow's theorems. I think it might be sensible to start sending some of it to mathlib. Before I start, does anyone have any comments about the proposal, naming conventions, or anything else? I feel bad adding more definitions of finiteness but I think these are the things we need for reasoning. When I was refactoring subgroups I ran into an issue in the proof of Sylow's theorem where we are proving there are subgroups of order p^n for all n&lt;=v_p(G); the n=0 case used <code>bot</code> and at some point I wanted to rewrite <code>card_bot</code> but unfortunately there are two proofs that the bot subgroup of a finite group is finite in mathlib -- one coming from the fact that it's the trivial group and one coming from the fact that a subset of a finite type is finite. This is just silly -- we don't need these subsingleton diamonds getting in the way when we are reasoning.</p>



<a name="206618412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206618412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206618412">(Aug 11 2020 at 19:15)</a>:</h4>
<p>What ever happened to definition irrelevance / API making? Instead of defining <code>finset2</code>, make an api that lets you treat a <code>finset</code> like a <code>finset2</code></p>



<a name="206618856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206618856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206618856">(Aug 11 2020 at 19:19)</a>:</h4>
<p>Agree with Mario here, nothing about finset forces you to be constructive.</p>



<a name="206619038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206619038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206619038">(Aug 11 2020 at 19:20)</a>:</h4>
<p>I think my definition of <code>finsum</code> is strictly more powerful than your <code>sum</code> too. If you are going to have no well definedness assumptions, you may as well have it give a reasonable result on the widest possible domain</p>



<a name="206619278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206619278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206619278">(Aug 11 2020 at 19:22)</a>:</h4>
<p>Oops, it appears this is a thread-spanning topic now. I'm referring to <a href="#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206415746">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206415746</a></p>



<a name="206619862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206619862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206619862">(Aug 11 2020 at 19:27)</a>:</h4>
<p>Yeah sorry, I had to choose whether to go with this thread or that one.</p>



<a name="206621224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621224">(Aug 11 2020 at 19:39)</a>:</h4>
<p>finsum is fine by me -- I was just using something Jeremy knocked up for MIL. I'm not sure I understand the finset2 thing though. I was 100% sure I used finset2 to make is_finite but I just removed the import and don't use it at all. So should I ditch finset2? I'm not sure I even need it now.</p>



<a name="206621416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621416">(Aug 11 2020 at 19:40)</a>:</h4>
<p>So is the point that we just don't define <code>finset2</code> at all, prove that <code>{S : set X // finite S} ≃ (finset X)</code> and then for every lemma about finsets I prove some analogous lemma for set.finite?</p>



<a name="206621784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621784">(Aug 11 2020 at 19:43)</a>:</h4>
<p>In what sense is that not already done in mathlib?</p>



<a name="206621847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621847">(Aug 11 2020 at 19:44)</a>:</h4>
<p>set.finite has lots of lemmas generated exactly that way, and they are all very easy</p>



<a name="206621865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621865">(Aug 11 2020 at 19:44)</a>:</h4>
<p>so you can add more if something is missing without too much trouble</p>



<a name="206622282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206622282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206622282">(Aug 11 2020 at 19:48)</a>:</h4>
<p>I am confused about why we don't want <code>finset2</code>. What were the problems with <code>is_subgroup</code> which made us switch to <code>subgroup</code>? Were there actually no problems and we just decided that we wanted the cool dot notation?</p>



<a name="206622352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206622352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206622352">(Aug 11 2020 at 19:49)</a>:</h4>
<p>it was a class</p>



<a name="206630145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630145">(Aug 11 2020 at 20:55)</a>:</h4>
<p>So <code>set.finite</code> and <code>set.infinite</code> should not be classes? Here's the current definitions (mostly due to other people):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum_in</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">finsum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span> <span class="k">then</span> <span class="n">f</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">localized</span> <span class="s2">&quot;notation `∑` binders `, ` r:(scoped:67 f, finsum f) := r&quot;</span> <span class="k">in</span> <span class="n">finsum</span>
<span class="n">localized</span> <span class="s2">&quot;notation `∑` binders ` in ` s `, ` r:(scoped:67 f, finsum_in s f) := r&quot;</span> <span class="k">in</span> <span class="n">finsum</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">set</span><span class="bp">.</span><span class="n">card</span> <span class="o">{</span><span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="mi">1</span>

<span class="n">def</span> <span class="n">is_finite</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">X</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">is_finite</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">is_finite</span> <span class="n">X</span> <span class="k">then</span> <span class="bp">@</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">X</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="206630312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630312">(Aug 11 2020 at 20:57)</a>:</h4>
<p>I think <code>set.card</code> should be defined directly rather than by summing ones, but the definition will be equivalent regardless so it's not that important</p>



<a name="206630380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630380">(Aug 11 2020 at 20:57)</a>:</h4>
<p><code>set.card s := fincard (\u s)</code> for example</p>



<a name="206630474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630474">(Aug 11 2020 at 20:58)</a>:</h4>
<p>also <code>set.finite</code> can be refactored on top of <code>is_finite</code></p>



<a name="206630585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630585">(Aug 11 2020 at 20:59)</a>:</h4>
<p>As for making <code>is_finite</code> a class, I think it will work okay, but it will be about as good as <code>fintype</code> for what it does</p>



<a name="206630713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630713">(Aug 11 2020 at 21:00)</a>:</h4>
<p>In particular, AFAICT all the gripes about <code>fintype</code> are eliminated if it is excised from definitions such as <code>fincard</code></p>



<a name="206630869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630869">(Aug 11 2020 at 21:01)</a>:</h4>
<p>wait -- are you telling me that the def of <code>fincard</code> should be rethought?</p>



<a name="206630935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630935">(Aug 11 2020 at 21:02)</a>:</h4>
<p>no, I'm saying that it solves the bulk of the problems on its own</p>



<a name="206631019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631019">(Aug 11 2020 at 21:03)</a>:</h4>
<p>As long as the <code>fintype</code> instance doesn't occur in the statement of theorems using finiteness, it should be fine to appear as a hypothesis</p>



<a name="206631103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631103">(Aug 11 2020 at 21:03)</a>:</h4>
<p>so perhaps the <code>is_finite</code> class isn't so important</p>



<a name="206631172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631172">(Aug 11 2020 at 21:04)</a>:</h4>
<p>This is not just navel-gazing for its own sake -- I'm trying to use finiteness to prove results in group theory. The idea of decreeing that "we will only take sizes of sets" or "...of types" sounded appealing to me, but I've seen explicit examples today where you really have to move between sets and types.</p>



<a name="206631258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631258">(Aug 11 2020 at 21:04)</a>:</h4>
<p>I'm still not convinced that you can't just use <code>fintype (\u s)</code> for talking about sets in a world of classes on types</p>



<a name="206631338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631338">(Aug 11 2020 at 21:05)</a>:</h4>
<p>The main use of <code>is_finite</code> is not as a class but as a hypothesis, a proposition to be used however you use propositions</p>



<a name="206631364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631364">(Aug 11 2020 at 21:05)</a>:</h4>
<p>How are you proposing saying things like "if p is a partition of the finite type X then the sum of the sizes of the blocks of p equals the size of X"?</p>



<a name="206631452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631452">(Aug 11 2020 at 21:06)</a>:</h4>
<p><code>theorem foo [fintype X] : ... fincard X</code></p>



<a name="206631499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631499">(Aug 11 2020 at 21:07)</a>:</h4>
<p>But you need to count all the subsets too</p>



<a name="206631530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631530">(Aug 11 2020 at 21:07)</a>:</h4>
<p>you have a set of subsets -- you don't really want to convert all of these to types, do you?</p>



<a name="206631532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631532">(Aug 11 2020 at 21:07)</a>:</h4>
<p><code>finsum (\lam p, fincard p) = fincard X</code></p>



<a name="206631550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631550">(Aug 11 2020 at 21:07)</a>:</h4>
<p>it's fine, let coercion do its magic</p>



<a name="206631698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631698">(Aug 11 2020 at 21:09)</a>:</h4>
<p>In practice I was using <code>is_finite</code> in the fincard proofs because most of them are case splits on whether something is finite or not. So it was very convenient to have <code>is_finite</code> as a class because i could just dump it into the inference system and then not worry about it. But I guess that given that I had it, I could just feed it into the theorems I need rather than doing the <code>resetI</code> dance</p>



<a name="206631843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631843">(Aug 11 2020 at 21:11)</a>:</h4>
<p>Amusing thing: when doing some set lemmas I realised I was constantly splitting on whether something was finite or infinite, and they were both classes, so I proved that every set was finite or infinite and then was doing <code>cases; resetI</code>. I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>



<a name="206632005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632005">(Aug 11 2020 at 21:12)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">p</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">partition_sum</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finsum_in</span> <span class="n">P</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">fincard</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fincard</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>easy peasy</p>



<a name="206632046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632046">(Aug 11 2020 at 21:12)</a>:</h4>
<p>(I won't prove it right now because <code>fincard</code> et al don't have an API yet)</p>



<a name="206632059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632059">(Aug 11 2020 at 21:12)</a>:</h4>
<p>that's a bad theorem, it uses the forbidden fintype</p>



<a name="206632084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632084">(Aug 11 2020 at 21:13)</a>:</h4>
<p>No, the fintype does not appear in the statement of the theorem, so you can just get it from wherever you like</p>



<a name="206632124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632124">(Aug 11 2020 at 21:13)</a>:</h4>
<p>you won't have unification problems as a result</p>



<a name="206632150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632150">(Aug 11 2020 at 21:13)</a>:</h4>
<p>Oh I see. But you should prove this for <code>is_finite</code> because it's more general</p>



<a name="206632225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632225">(Aug 11 2020 at 21:14)</a>:</h4>
<p>it's (constructively, even) equivalent</p>



<a name="206632330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632330">(Aug 11 2020 at 21:15)</a>:</h4>
<p>then you should prove it for <code>is_finite</code> because fintype is deprecated?</p>



<a name="206632338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632338">(Aug 11 2020 at 21:15)</a>:</h4>
<p>the idea with this proposal is that you use <code>fintype</code> for your typeclass needs and reserve <code>is_finite</code> as a regular hypothesis that you can pop open when you want to teach the typeclass system</p>



<a name="206632435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632435">(Aug 11 2020 at 21:16)</a>:</h4>
<p>I thought I never wanted to use <code>fintype</code> ever again?</p>



<a name="206632463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632463">(Aug 11 2020 at 21:16)</a>:</h4>
<p>It already has all the "structural" instances you want</p>



<a name="206632512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632512">(Aug 11 2020 at 21:17)</a>:</h4>
<p>the bad thing about fintype is that because it is a Type, you can get into unification issues like patrick mentioned at the start of the other thread</p>



<a name="206632545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632545">(Aug 11 2020 at 21:17)</a>:</h4>
<p>but as long as you use <code>fincard</code> instead of <code>fintype.card</code> that problem goes away</p>



<a name="206735086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206735086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206735086">(Aug 12 2020 at 18:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/206631843">said</a>:</p>
<blockquote>
<p>I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>
</blockquote>
<p>on a related note, I just discovered <code>fconstructor</code></p>



<a name="206839142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206839142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206839142">(Aug 13 2020 at 16:41)</a>:</h4>
<p>Jason wanted to make an API for <code>finsum</code> (which was defined by Mario to be)</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>and he realised that what he wanted was to prove that it equalled finset.sum. This would be easier if we used the following definition:</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="k">then</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>Are there disadvantages to <code>finsum2</code> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ?</p>



<a name="206843947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206843947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206843947">(Aug 13 2020 at 17:23)</a>:</h4>
<p>which one has less imports?</p>



<a name="206843977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206843977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206843977">(Aug 13 2020 at 17:23)</a>:</h4>
<p>Either way you want to prove both definitions are the same</p>



<a name="206844082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206844082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206844082">(Aug 13 2020 at 17:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span> <span class="n">data</span><span class="bp">.</span><span class="n">support</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="k">then</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kn">theorem</span> <span class="n">finsum_eq_finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finsum</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finsum2</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">finsum</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">finsum2</span><span class="o">,</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span><span class="o">,</span>
    <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">h1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">,</span>
      <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">h1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h1</span><span class="bp">.</span><span class="n">finite_supp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">h1</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">support</span> <span class="o">:=</span> <span class="n">h3</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
      <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">mem_support_to_fun</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function</span><span class="bp">.</span><span class="n">mem_support</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">],</span>
      <span class="kn">end</span> <span class="o">},</span>
    <span class="n">use</span> <span class="n">f&#39;</span><span class="o">,</span>
    <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span> <span class="bp">.</span>
</code></pre></div>



<a name="206844370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206844370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206844370">(Aug 13 2020 at 17:26)</a>:</h4>
<p>what is <code>finiteness.is_finite</code>?</p>



<a name="206844810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206844810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206844810">(Aug 13 2020 at 17:30)</a>:</h4>
<p>wow, I thought <code>function.support</code> would have an easy definition but the file that defines it has a ton of imports</p>



<a name="206845842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206845842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206845842">(Aug 13 2020 at 17:38)</a>:</h4>
<p>I thought we stopped caring about the import hierarchy 37 days ago</p>



<a name="206859914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206859914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206859914">(Aug 13 2020 at 19:35)</a>:</h4>
<p>This file has many imports because it was added after these imports</p>



<a name="206860011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206860011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206860011">(Aug 13 2020 at 19:36)</a>:</h4>
<p>It's easy to remove all imports if you move lemmas to other files</p>



<a name="206867649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206867649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206867649">(Aug 13 2020 at 20:34)</a>:</h4>
<p>Another insight from Chris at Xena this evening; how about this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ&#39;</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">)</span> <span class="k">then</span>
  <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elems</span> <span class="k">else</span> <span class="err">∅</span>

<span class="n">def</span> <span class="n">fincard&#39;</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ&#39;</span> <span class="n">X</span>
</code></pre></div>


<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> you had suggested</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">X</span><span class="o">)</span> <span class="k">then</span> <span class="bp">@</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">X</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>-- does this variant meet with your approval?</p>



<a name="206871712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871712">(Aug 13 2020 at 21:07)</a>:</h4>
<p>ha, clever</p>



<a name="206871749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871749">(Aug 13 2020 at 21:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I would go as far as saying that the <code>finset.univ</code> in mathlib should be replaced with your new <code>finset.univ'</code> etc.</p>



<a name="206871752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871752">(Aug 13 2020 at 21:07)</a>:</h4>
<p>that finset.univ' could be useful for many things</p>



<a name="206871817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871817">(Aug 13 2020 at 21:07)</a>:</h4>
<p>(etc. = the same for other definitions depending <strong>directly</strong> on fintype)</p>



<a name="207073922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207073922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207073922">(Aug 16 2020 at 14:33)</a>:</h4>
<p>OK so <span class="user-mention" data-user-id="243312">@Jason KY.</span> and I have been hacking away on this stuff, and we ran into something which presumably has been run into before. Recall we've been talking about these definitions (either will do for me but the finset one is easier to port with):</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="k">then</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>Jason pointed out that we should probably do products too -- but then we run into the following issue: finsupp and support both want a zero. Is there an analogous construction in Lean which does either of these things but with a 1?</p>



<a name="207074096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207074096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207074096">(Aug 16 2020 at 14:38)</a>:</h4>
<p>We can make <code>one_support</code> or whatever -- <code>function.one_support f</code> is the things which don't get mapped to one -- but then <code>to_additive</code> will turn this into <code>zero_support</code>. Presumably we can work around this? But do we want <code>one_support</code> at all?</p>



<a name="207733621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207733621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207733621">(Aug 22 2020 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/206631843">said</a>:</p>
<blockquote>
<p>so I proved that every set was finite or infinite and then was doing <code>cases; resetI</code>. I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>
</blockquote>
<p>I also just learned you can use it instead of unfreezing local instances.</p>



<a name="207735502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207735502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207735502">(Aug 22 2020 at 18:09)</a>:</h4>
<p>We can define <code>set.to_finset</code> using the same trick, then <code>finset.univ = univ.to_finset</code>, <code>fincard = finset.univ.card</code></p>



<a name="207736793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207736793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207736793">(Aug 22 2020 at 18:39)</a>:</h4>
<p>There's a <code>fincard</code> branch of mathlib by the way.</p>



{% endraw %}

<hr><p>Last updated: Oct 06 2020 at 10:10 UTC</p>