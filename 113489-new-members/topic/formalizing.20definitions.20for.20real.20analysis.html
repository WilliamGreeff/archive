---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html">formalizing definitions for real analysis</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204963923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204963923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204963923">(Jul 24 2020 at 20:39)</a>:</h4>
<p>I was wondering if someone might be able to suggest the best way to formalize the following, especially the definition of a partition.</p>
<p>1.1 Definition: A partition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> of a closed interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> is a finite sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_{0}, x_{1}, \ldots, x_{n})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mo>…</mo><mo>&lt;</mo><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = x_{0} &lt; x_{1} &lt; \ldots &lt; x_{n} = b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>. The norm of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, denoted <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">∣</mo><mrow><mo fence="true">∣</mo><mi>P</mi><mo fence="true">∣</mo></mrow><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\left|\left|P\right|\right|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span>, is defined by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mrow><mo fence="true">∣</mo><mi>P</mi><mo fence="true">∣</mo></mrow><mo fence="true">∣</mo></mrow><mo>=</mo><msub><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left|\left|P\right|\right| = \max_{1 \leq i \leq n} (x_{i} - x_{i-1})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>1.2 Definition: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = (x_{0}, \ldots, x_{n})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> be a partition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>, and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> be defined on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>. For each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>, let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo></mrow><annotation encoding="application/x-tex">x_{i}*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∗</span></span></span></span> be an arbitrary point in the interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x_{i-1}, x_{i}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>. Then any sum of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(f, P) = \sum_{i=1}^{n} f(x_{i}*)(x_{i} - x_{i-1})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∗</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is called a Riemann sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> relative to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</p>
<p>1.3 Definition: A function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is Riemann integrable on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> if there is a real number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, there exists a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta &gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> such that for any partition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> satisfying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mrow><mo fence="true">∣</mo><mi>P</mi><mo fence="true">∣</mo></mrow><mo fence="true">∣</mo></mrow><mo>&lt;</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\left|\left|P\right|\right| &lt; \delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>, and for any Riemann sum <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(f, P)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> relative to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi>R</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>−</mo><mi>R</mi><mo fence="true">∣</mo></mrow><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\left|R(f,P) - R\right| &lt; \epsilon</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>.</p>
<p>1.4 Definition: A function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>, defined on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>, is a step function if there is a partition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = (x_{0}, x_{1}, \ldots, x_{n})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is constant on each open subinterval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_{i-1}, x_{i})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p>



<a name="204964033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204964033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204964033">(Jul 24 2020 at 20:40)</a>:</h4>
<p>just don't use backticks</p>



<a name="204964053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204964053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204964053">(Jul 24 2020 at 20:40)</a>:</h4>
<p>and use double-dollar-signs, i.e. <code>$$\LaTeX$$</code> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord"><span class="mord textrm mtight sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span></p>



<a name="204964275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204964275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204964275">(Jul 24 2020 at 20:42)</a>:</h4>
<p>Thank you.</p>



<a name="204965063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965063">(Jul 24 2020 at 20:49)</a>:</h4>
<p>What theorems do you want to prove and how do the proofs go?</p>



<a name="204965331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965331">(Jul 24 2020 at 20:51)</a>:</h4>
<p>I would probably be inclined to go for a fairly literal translation (and, in particular, not invent a custom inductive type for a partition) in order to avoid reinventing lots of finset sum stuff.</p>



<a name="204965492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965492">(Jul 24 2020 at 20:52)</a>:</h4>
<p>I'm going through the exercises in the first chapter of "An Introduction to Lebesgue Integration and Fourier Series" by Howard J. Wilcox and David L. Myers. I'm attaching what I have done in latex. <a href="/user_uploads/3121/eC42X4k1t9MAH3_5jZn_Kh3m/myers.dvi">myers.dvi</a></p>



<a name="204965627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965627">(Jul 24 2020 at 20:53)</a>:</h4>
<p>(do you know that mathlib has lebesgue integration?)</p>



<a name="204965775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965775">(Jul 24 2020 at 20:55)</a>:</h4>
<p>I saw that directory, but I didn't understand it.</p>



<a name="204965870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965870">(Jul 24 2020 at 20:55)</a>:</h4>
<p>yury gave some tutorials about this part of the library at lftcm2020</p>



<a name="204965936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965936">(Jul 24 2020 at 20:56)</a>:</h4>
<p>there are exercises you can get with <code>leanproject get lftcm2020</code> and a <a href="https://www.youtube.com/watch?v=p8Etfv1_VqQ">video lecture</a></p>
<div class="youtube-video message_inline_image"><a data-id="p8Etfv1_VqQ" href="https://www.youtube.com/watch?v=p8Etfv1_VqQ"><img src="https://i.ytimg.com/vi/p8Etfv1_VqQ/default.jpg"></a></div>



<a name="204966046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204966046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204966046">(Jul 24 2020 at 20:57)</a>:</h4>
<p>the rest of the talks are on the same youtube channel :)</p>



<a name="204966084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204966084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204966084">(Jul 24 2020 at 20:57)</a>:</h4>
<p>Cool. I'll take a look.</p>



<a name="204967671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204967671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204967671">(Jul 24 2020 at 21:14)</a>:</h4>
<p>The ultimate aim of the work described here would be to formally define an integral which is strictly weaker than an integral we have already. However, if you write the proofs in tactic mode with comments then it would be an excellent pedagogical resource.</p>



<a name="204967913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204967913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204967913">(Jul 24 2020 at 21:17)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> if you're thinking of developing the theory with pedagogy in mind then you might want to make new notation for a partition. Reid's point is a partition is just a finset containing a and b, and that the moment things get tough you are going to be unfolding the definition of a partition because all the lemmas about finsets which you'll need won't be rewritable until we can see the finset.</p>



<a name="204968289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968289">(Jul 24 2020 at 21:20)</a>:</h4>
<p>Yes, it is for pedagogy. Sorry, I'm not sure if you are saying if I should or should not define it as a finset in lean.</p>



<a name="204968308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968308">(Jul 24 2020 at 21:21)</a>:</h4>
<p>If you're trying to write golfy term mode proofs for mathlib, this (making a new definition) will become tedious. But if you're happy to write tactic mode proofs then this will not be a bother at all. Taking Reid's argument to its natural conclusion, the lean idiomatic way would be to think of a partition as a nonempty finset of reals and you then define a and b to be the min and max. No new definition needed. The computer scientists would argue that the definition in your maths book is lousy because it's inconvenient to use in term mode. They say the fewer definitions the better. But I'm coming to the conclusion that there's some merit in ignoring the computer scientists and developing things the normal maths way. I just did three live streams about topological spaces and compact sets etc and I never once used a filter, I did it all the way I was taught. It's not going in mathlib but it's instructive for mathematicians</p>



<a name="204968641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968641">(Jul 24 2020 at 21:24)</a>:</h4>
<p>What are "golfy term mode proofs"?</p>



<a name="204968686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968686">(Jul 24 2020 at 21:25)</a>:</h4>
<p>Does that just mean really compact proofs or something more?</p>



<a name="204968775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968775">(Jul 24 2020 at 21:26)</a>:</h4>
<p>I really meant something like <code>(n : nat) (x : fin (n+1) -&gt; real) (h0 : x 0 = a) ...</code></p>



<a name="204968806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968806">(Jul 24 2020 at 21:27)</a>:</h4>
<p>I would suggest trying to formulate and prove a theorem about telescoping sums which amounts to the calculation of a Riemann sum for a constant function</p>



<a name="204968910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968910">(Jul 24 2020 at 21:28)</a>:</h4>
<p>Is that code a suggestion for the definition of a partition?</p>



<a name="204968991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968991">(Jul 24 2020 at 21:29)</a>:</h4>
<p>Yes</p>



<a name="204969090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204969090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204969090">(Jul 24 2020 at 21:30)</a>:</h4>
<p>I see.</p>



<a name="204970361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970361">(Jul 24 2020 at 21:48)</a>:</h4>
<p>Why this rather than a finite set of reals? I haven't worked with fin before.</p>



<a name="204970407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970407">(Jul 24 2020 at 21:49)</a>:</h4>
<p>You can think of <code>fin n \to \R</code> as an ordered n-tuple of real numbers.</p>



<a name="204970434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970434">(Jul 24 2020 at 21:49)</a>:</h4>
<p>So the difference is to make it ordered?</p>



<a name="204970565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970565">(Jul 24 2020 at 21:51)</a>:</h4>
<p>It might help to see what the full definition in Lean would look like.</p>



<a name="204970575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970575">(Jul 24 2020 at 21:51)</a>:</h4>
<p>Yes. Mathematically, it's the difference between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,\ldots,x_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x_1,\ldots,x_n\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>.</p>



<a name="204971239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971239">(Jul 24 2020 at 22:01)</a>:</h4>
<p>Are we defining a proposition like, is_partition, or the partition itself?</p>



<a name="204971407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971407">(Jul 24 2020 at 22:03)</a>:</h4>
<p>I thought a bit more about this and I agree with Reid. The disadvantage with a finset is that there is no good interface to access the i'th element. Lists would also be a pain because you probably won't be concatenating them or appending to the left, you will be mostly using them via their i'th element, so Reid's suggestion of a map from fin(n+1) (to ensure non-emptiness) to real is I think the best. Make a new definition! When you use it you'll figure out what API you'll need for it. I would love to watch the progress of this one.</p>



<a name="204971452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971452">(Jul 24 2020 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204970575">said</a>:</p>
<blockquote>
<p>Yes. Mathematically, it's the difference between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,\ldots,x_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x_1,\ldots,x_n\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>.</p>
</blockquote>
<p>Wait, with this definition I don't see where's the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">x_0 &lt; x_1 &lt; \ldots </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span>. Isn't it just a tuple, with no order between the values?</p>



<a name="204971479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971479">(Jul 24 2020 at 22:04)</a>:</h4>
<p>You can still do it inductively with <code>fin</code>.</p>



<a name="204971496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971496">(Jul 24 2020 at 22:04)</a>:</h4>
<p>Since <code>fin.tail</code> is a thing.</p>



<a name="204971538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971538">(Jul 24 2020 at 22:05)</a>:</h4>
<p>You can define a partition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> of length n as the data of a partition of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a_1,b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>∈</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_1 \in (a,b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</p>



<a name="204971598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971598">(Jul 24 2020 at 22:06)</a>:</h4>
<p>And defining the empty partition is easy :)</p>



<a name="204971614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971614">(Jul 24 2020 at 22:06)</a>:</h4>
<p>That's what I thought. I had actually started doing that myself some time ago.<br>
At that time I didn't know about <code>fin.tail</code>.</p>



<a name="204971670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971670">(Jul 24 2020 at 22:07)</a>:</h4>
<p>To do this inductive definition, you just need to get the element in <code>fin (n+1)</code> corresponding to the value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, which is <code>(0 : fin n).succ</code>, I guess.</p>



<a name="204971774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971774">(Jul 24 2020 at 22:08)</a>:</h4>
<p><span class="user-mention" data-user-id="259857">@Dan Stanescu</span> yeah you have to add a proof that x_i &lt; x_{i+1}. Reid wrote <code>...</code>, he didn't finish the definition. He did the data part and left the other mathematicians to do the proof part.</p>



<a name="204971827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971827">(Jul 24 2020 at 22:09)</a>:</h4>
<p>The rest is just the same, translate "for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_i &lt; x_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>" as something involving <code>∀ i : fin n, ...</code> or whatever.</p>



<a name="204971925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971925">(Jul 24 2020 at 22:10)</a>:</h4>
<p>Maybe it would be convenient to extend <code>x</code> to all of <code>nat</code> or even <code>int</code> by setting it to <code>a</code>/<code>b</code> outside the range <code>fin n</code></p>



<a name="204971930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971930">(Jul 24 2020 at 22:10)</a>:</h4>
<p>Unfortunately, <code>(i : fin n).succ</code> has type <code>fin (n+1)</code>.</p>



<a name="204971934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971934">(Jul 24 2020 at 22:10)</a>:</h4>
<p>I'm not sure that it will help to do the definition inductively. You're going to have a lot of lemmas where P is a partition and i is less than n and you want to talk about the interval [x_i, x_{i+1}]. If you make some fancy inductive definition then you'll have to work to get to the x_i</p>



<a name="204971954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971954">(Jul 24 2020 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204971930">said</a>:</p>
<blockquote>
<p>Unfortunately, <code>(i : fin n).succ</code> has type <code>fin (n+1)</code>.</p>
</blockquote>
<p>Yes, which is the input of <code>x</code></p>



<a name="204971963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971963">(Jul 24 2020 at 22:11)</a>:</h4>
<p>Oh right :)</p>



<a name="204971987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971987">(Jul 24 2020 at 22:11)</a>:</h4>
<p>So yes, I agree this is the best option :)</p>



<a name="204972054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972054">(Jul 24 2020 at 22:12)</a>:</h4>
<p>You do have to do some cast to turn <code>i : fin n</code> to <code>i : fin (n+1)</code></p>



<a name="204972076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972076">(Jul 24 2020 at 22:12)</a>:</h4>
<p>Doesn't this exist as a coersion?</p>



<a name="204972128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972128">(Jul 24 2020 at 22:13)</a>:</h4>
<p>Not sure but it certainly exists in some form</p>



<a name="204972183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972183">(Jul 24 2020 at 22:14)</a>:</h4>
<p>I'm not sure I follow, but I think what Kevin said makes sense?</p>



<a name="204972189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972189">(Jul 24 2020 at 22:14)</a>:</h4>
<p>A good place to ask, would Riemann integrals still have a place somewhere in <code>mathlib</code> now? Same for Dedekind cuts.</p>



<a name="204972210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972210">(Jul 24 2020 at 22:14)</a>:</h4>
<p>Do you think it's worth storing the differences of the x_i, instead of the x_i themselves? Then you could use a <code>finsupp</code>.</p>



<a name="204972388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972388">(Jul 24 2020 at 22:17)</a>:</h4>
<p>You're also going to need to talk about points <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_i &lt; x &lt; x_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="204972464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972464">(Jul 24 2020 at 22:18)</a>:</h4>
<p>The partitions will at points probably need to be broken apart into sets of subintervals with sums over those sets.</p>



<a name="204972469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972469">(Jul 24 2020 at 22:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204972128">said</a>:</p>
<blockquote>
<p>Not sure but it certainly exists in some form</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast_succ/src">src#fin.cast_succ</a></p>



<a name="204972495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972495">(Jul 24 2020 at 22:19)</a>:</h4>
<p>You can have a finsupp from nat or int to nnreal and then just define the x_i as partial sums.</p>



<a name="204972496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972496">(Jul 24 2020 at 22:19)</a>:</h4>
<p>Just in case it's helpful later.</p>



<a name="204972642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972642">(Jul 24 2020 at 22:21)</a>:</h4>
<p>Why is the function from fin (n + 1) \to \real and not \nat \to \real?</p>



<a name="204972702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972702">(Jul 24 2020 at 22:22)</a>:</h4>
<p>Well that's what your informal definition said right?</p>



<a name="204972752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972752">(Jul 24 2020 at 22:23)</a>:</h4>
<p>I guess I'm not sure what fin (n + 1) to real means? Is fin (n+1) a set?</p>



<a name="204972759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972759">(Jul 24 2020 at 22:23)</a>:</h4>
<p>It is the canonical type with n+1 elements</p>



<a name="204972773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972773">(Jul 24 2020 at 22:23)</a>:</h4>
<p>did you ask lean what <code>fin (n+1)</code> means?</p>



<a name="204972842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972842">(Jul 24 2020 at 22:24)</a>:</h4>
<p>You need a list of reals with n+1 elements and you need easy access to the i'th element of the list, so why not store the list internally as a function from a type with n+1 elements with names like 0,1,2,..,n to the reals.</p>



<a name="204972897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972897">(Jul 24 2020 at 22:25)</a>:</h4>
<p><code>fin m</code> is a type. A term of type <code>fin m</code> is a pair consisting of a natural number i and a proof that i&lt;m. You take a term of this type apart with <code>cases</code>, which gives you the pair (the number and the proof), and you build terms of this type with the <code>\&lt;i, hi\&gt;</code> constructor, where i is a nat and hi is a proof that i&lt;m.</p>



<a name="204973300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973300">(Jul 24 2020 at 22:32)</a>:</h4>
<p>So fin m is not the type of finite ordered sets of natural numbers? I think I'm starting to see.</p>



<a name="204973341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973341">(Jul 24 2020 at 22:33)</a>:</h4>
<p>what would the <code>m</code> be doing there?</p>



<a name="204973342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973342">(Jul 24 2020 at 22:33)</a>:</h4>
<p><code>fin m</code> is exactly what I said it is. You can just <code>#check fin</code> if you have any more questions.</p>



<a name="204973349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973349">(Jul 24 2020 at 22:33)</a>:</h4>
<p>or #print</p>



<a name="204973397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973397">(Jul 24 2020 at 22:34)</a>:</h4>
<p>to elaborate on kevin's point, there's a literal definition and it is not very long</p>



<a name="204973400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973400">(Jul 24 2020 at 22:34)</a>:</h4>
<p>sorry yeah -- <code>#check fin</code> and then right click on <code>fin</code> and go to definition!</p>



<a name="204973413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973413">(Jul 24 2020 at 22:34)</a>:</h4>
<p>so if you read the definition you should either understand it or be able to find a part of it you don't understand</p>



<a name="204973435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973435">(Jul 24 2020 at 22:35)</a>:</h4>
<p>In math notation: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">fin</mi><mo>⁡</mo><mi>n</mi><mo>:</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>x</mi><mo>&lt;</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> \operatorname{fin} n := \{ x \in \mathbb{N} \ | \ x &lt; n \}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span></p>



<a name="204973442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973442">(Jul 24 2020 at 22:35)</a>:</h4>
<p>except that it's a type, not a set</p>



<a name="204973458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973458">(Jul 24 2020 at 22:35)</a>:</h4>
<p>yeah, in lean <code>fin n := { x : \N // x &lt; n }</code></p>



<a name="204973515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973515">(Jul 24 2020 at 22:36)</a>:</h4>
<p>so in set theory you have <code>fin n \subseteq fin (n+1)</code> but in Lean this doesn't even make sense because <code>\subseteq</code> is for (sub)sets</p>



<a name="204973611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973611">(Jul 24 2020 at 22:38)</a>:</h4>
<p>You can see why <code>fin n</code> isn't a sub-thing of <code>fin (n+1)</code> because to give a term of type <code>fin n</code> is to give a pair (i,h) with h a proof that i&lt;n, and so now you don't have immediate access to a proof that i&lt;(n+1), you'll have to make this proof, and that is the content of the canonical map from fin n to fin(n+1) (it's not "the identity" -- work needs to be done)</p>



<a name="204973653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973653">(Jul 24 2020 at 22:39)</a>:</h4>
<p>I think I get it.</p>



<a name="204973774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973774">(Jul 24 2020 at 22:41)</a>:</h4>
<p>Thank you.</p>



<a name="204973861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973861">(Jul 24 2020 at 22:42)</a>:</h4>
<p>I think it's a good exercise to write this definition. And here are some components which you'll need:</p>
<ol>
<li><code>fin.succ</code> is the successor function <code>fin n \to fin (n+1)</code>.</li>
<li>You can just write 0 for the first element of <code>fin (n+1)</code></li>
<li>You can write <code>fin.last n</code> for the last element of <code>fin (n+1)</code>.</li>
<li><code>fin.cast_succ</code> is the obvious inclusion <code>fin n \to fin (n+1)</code> that Kevin mentioned.</li>
</ol>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.last/src">src#fin.last</a> <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.succ/src">src#fin.succ</a> <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast_succ/src">src#fin.cast_succ</a></p>



<a name="204974003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974003">(Jul 24 2020 at 22:45)</a>:</h4>
<p>This would be an inductive definition? Kevin mentioned that maybe an inductive definition might not be ideal?</p>



<a name="204974019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974019">(Jul 24 2020 at 22:45)</a>:</h4>
<p>No. This is if you want to follow Reid's suggestion.</p>



<a name="204974812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974812">(Jul 24 2020 at 22:59)</a>:</h4>
<p>To be honest, I'm not sure I have a good idea of what form that definition would take. What would be the final type returned?</p>



<a name="204974839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974839">(Jul 24 2020 at 22:59)</a>:</h4>
<p>The function?</p>



<a name="204975166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975166">(Jul 24 2020 at 23:05)</a>:</h4>
<p>You probably want a function with two real numbers <code>a</code> and <code>b</code> and the tuple <code>as : fin (n+1) \to \R</code> as inputs, and a <code>Prop</code> as the output. This should say that the <code>as</code> are the endpoints of the intervals of a partition of the interval with endpoints <code>a</code> and <code>b</code>.</p>



<a name="204975367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975367">(Jul 24 2020 at 23:08)</a>:</h4>
<p>Would it also take a proof that x_{0} &lt; x_{1} &lt; ... x_{n} as an input?</p>



<a name="204975412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975412">(Jul 24 2020 at 23:09)</a>:</h4>
<p>No, I guess that proof would be part of the returned Prop?</p>



<a name="204975478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975478">(Jul 24 2020 at 23:10)</a>:</h4>
<p>I was rather thinking about a function that takes <code>a</code>, <code>b</code> and <code>n</code> as inputs and returns a tuple.<br>
And the proof(s) that the points in the tuple are ordered, the first is <code>a</code> etc.</p>



<a name="204975502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975502">(Jul 24 2020 at 23:11)</a>:</h4>
<p>But there are many partitions of any given interval</p>



<a name="204975512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975512">(Jul 24 2020 at 23:11)</a>:</h4>
<p>True.</p>



<a name="204975708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975708">(Jul 24 2020 at 23:14)</a>:</h4>
<p>I can still say things like "Let P be a partition such that ||P|| &lt; \delta" right? I just need to prove that one exists, probably by constructing it?</p>



<a name="204976128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976128">(Jul 24 2020 at 23:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259857">Dan Stanescu</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204972189">said</a>:</p>
<blockquote>
<p>A good place to ask, would Riemann integrals still have a place somewhere in <code>mathlib</code> now? Same for Dedekind cuts.</p>
</blockquote>
<p>I would say yes.</p>



<a name="204976213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976213">(Jul 24 2020 at 23:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204975708">said</a>:</p>
<blockquote>
<p>I can still say things like "Let P be a partition such that ||P|| &lt; \delta" right? I just need to prove that one exists, probably by constructing it?</p>
</blockquote>
<p>In my view you could, but I'm not sure you could do that if you have a <code>Prop</code>.  <span class="user-mention" data-user-id="243562">@Adam Topaz</span> ?</p>



<a name="204976300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976300">(Jul 24 2020 at 23:27)</a>:</h4>
<p>You can use this prop to define a subtype, etc.</p>



<a name="204976537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976537">(Jul 24 2020 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204976128">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="259857">Dan Stanescu</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204972189">said</a>:</p>
<blockquote>
<p>A good place to ask, would Riemann integrals still have a place somewhere in <code>mathlib</code> now? Same for Dedekind cuts.</p>
</blockquote>
<p>I would say yes.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Where would you see them going to? The archive?</p>



<a name="204976600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976600">(Jul 24 2020 at 23:32)</a>:</h4>
<p>I think just a subdirectory called <code>riemann_integral</code> somewhere. Obviously it should have a thorough explanation in the module doc-strings that the rest of mathlib is build on top of more general constructions of integration.</p>



<a name="204976606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976606">(Jul 24 2020 at 23:32)</a>:</h4>
<p>Others may have other opinions on this, however.</p>



<a name="204976622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976622">(Jul 24 2020 at 23:33)</a>:</h4>
<p>Would it just be:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="204976625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976625">(Jul 24 2020 at 23:33)</a>:</h4>
<p>We've got ZFC even though we're working in type theory, why not have Riemann integrals even though we're using Bochner? :-)</p>



<a name="204977770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204977770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204977770">(Jul 24 2020 at 23:57)</a>:</h4>
<p>How do you make a type out of a proposition?</p>



<a name="204977838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204977838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204977838">(Jul 24 2020 at 23:58)</a>:</h4>
<p>Propositions are types. Proofs of a proposition are terms of that type.</p>



<a name="204978101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978101">(Jul 25 2020 at 00:03)</a>:</h4>
<p>I guess I'm not sure how I say let P be a partition of [a, b] such that...</p>



<a name="204978290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978290">(Jul 25 2020 at 00:06)</a>:</h4>
<p>Is you define <code>is_partition {n} (a b : \R) (as : fin (n+1) \to \R)</code> then you would have some <code>as</code> with a proof of that prop.</p>



<a name="204978311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978311">(Jul 25 2020 at 00:07)</a>:</h4>
<p>And the "such that" depends on what "such that" actually is.</p>



<a name="204978341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978341">(Jul 25 2020 at 00:08)</a>:</h4>
<p>If "such that" is another prop, just include a proof of that prop as a variable</p>



<a name="204978391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978391">(Jul 25 2020 at 00:08)</a>:</h4>
<p>I would make a <code>structure partition (a b : ℝ) := ...</code></p>



<a name="204979013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204979013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204979013">(Jul 25 2020 at 00:22)</a>:</h4>
<p>Also, how would you ever formalize the theorem that the riemann integral is weaker than the lebesgue integral without a formalization of the former?</p>



<a name="204979021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204979021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204979021">(Jul 25 2020 at 00:22)</a>:</h4>
<p>Same deal with dedekind reals being isomorphic to cauchy reals</p>



<a name="204979051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204979051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204979051">(Jul 25 2020 at 00:23)</a>:</h4>
<p>Turing machines are already in mathlib for this exact reason - even though the "official" foundations use partial recursive functions, we need the definition of a TM in order to state and prove the equivalence</p>



<a name="204980758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204980758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204980758">(Jul 25 2020 at 01:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204978391">said</a>:</p>
<blockquote>
<p>I would make a <code>structure partition (a b : ℝ) := ...</code></p>
</blockquote>
<p>I'm not sure I follow. Does the structure use the proposition?</p>



<a name="204980995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204980995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204980995">(Jul 25 2020 at 01:08)</a>:</h4>
<p><code>n</code>, <code>x</code>, all the <code>n &gt; 0</code> etc. would be fields.</p>



<a name="204981342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981342">(Jul 25 2020 at 01:18)</a>:</h4>
<p>I'm not sure I understand how a value of type partition would be guaranteed to be a partition. I'm looking through the documentation on structures here: <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html">https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html</a></p>



<a name="204981366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981366">(Jul 25 2020 at 01:19)</a>:</h4>
<p>your structure will be a bundle of data and propositions about that data</p>



<a name="204981416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981416">(Jul 25 2020 at 01:20)</a>:</h4>
<p>the subtype notation used in the definition of <code>fin n</code> is an example of a <code>structure</code></p>



<a name="204981425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981425">(Jul 25 2020 at 01:21)</a>:</h4>
<p>So one of the fields would be the is_partition proposition for example?</p>



<a name="204981430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981430">(Jul 25 2020 at 01:21)</a>:</h4>
<p>right, and if your proposition has an <code>and</code> in it, you probably want to break it into two fields</p>



<a name="204981493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981493">(Jul 25 2020 at 01:23)</a>:</h4>
<p><code>fin n</code> is an example of a structure</p>



<a name="204981545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981545">(Jul 25 2020 at 01:24)</a>:</h4>
<p>Can I then define a variable of type partition like I define a variable of type real, or do I have to always provide the fields?</p>



<a name="204981547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981547">(Jul 25 2020 at 01:24)</a>:</h4>
<p>it's morally equivalent (maybe literally defeq) to </p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="err">\</span><span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="err">\</span><span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="204981554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981554">(Jul 25 2020 at 01:24)</a>:</h4>
<p>I don't understand your question</p>



<a name="204981576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981576">(Jul 25 2020 at 01:25)</a>:</h4>
<p>I can say "let P be a partition" without constructing one?</p>



<a name="204981620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981620">(Jul 25 2020 at 01:26)</a>:</h4>
<p>Yes, e.g. if you have <code>structure partition (a b : ℝ) := ...</code> then later you can say</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">partition_eq_foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">foo</span>
</code></pre></div>



<a name="204981629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981629">(Jul 25 2020 at 01:26)</a>:</h4>
<p><code>partition</code> has type <code>\R \to \R \to Type</code></p>



<a name="204981642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981642">(Jul 25 2020 at 01:27)</a>:</h4>
<p>Cool. Do I have to show that there is such a thing as a partition? That is, that the definition is not self contradicting?</p>



<a name="204981646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981646">(Jul 25 2020 at 01:27)</a>:</h4>
<p>no</p>



<a name="204981690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981690">(Jul 25 2020 at 01:28)</a>:</h4>
<p>you could define a partition and then prove </p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">partition_eq_foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span>
</code></pre></div>



<a name="204981692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981692">(Jul 25 2020 at 01:28)</a>:</h4>
<p>(If you PR it to mathlib, the <code>inhabited</code> linter might want you to construct an instance.)</p>



<a name="204981702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981702">(Jul 25 2020 at 01:29)</a>:</h4>
<p>of course it is a good idea to construct an example as part of convincing yourself the definition is correct</p>



<a name="204981712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981712">(Jul 25 2020 at 01:29)</a>:</h4>
<p>you should also try to prove lemmas that are mathematically obvious</p>



<a name="204981772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981772">(Jul 25 2020 at 01:30)</a>:</h4>
<p>Interesting.</p>



<a name="204981789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981789">(Jul 25 2020 at 01:31)</a>:</h4>
<p>this is the same as saying that you don't have to prove a proposition in order to talk about it</p>



<a name="204981839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981839">(Jul 25 2020 at 01:32)</a>:</h4>
<p>You can write <code>def fermat : Prop := \ex a b c n, n &gt; 2 \and a \ne 0 \and a ^ n = b^n + c^n</code></p>



<a name="204981914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981914">(Jul 25 2020 at 01:34)</a>:</h4>
<p>Makes sense I guess.</p>



<a name="204981937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981937">(Jul 25 2020 at 01:35)</a>:</h4>
<p>a <code>def</code> is like a 0-field <code>structure</code></p>



<a name="204982396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982396">(Jul 25 2020 at 01:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_partition</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="204982452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982452">(Jul 25 2020 at 01:50)</a>:</h4>
<p>Or is it better to combine them into just the structure?</p>



<a name="204982521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982521">(Jul 25 2020 at 01:52)</a>:</h4>
<p>Depends if you anticipate using <code>is_partition</code> outside of defining <code>partition</code> instances.</p>



<a name="204982536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982536">(Jul 25 2020 at 01:54)</a>:</h4>
<p>True.</p>



<a name="204983491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983491">(Jul 25 2020 at 02:19)</a>:</h4>
<p>I think about formalizing Riemann integral too. Still not sure what is the best way to deal with it.</p>



<a name="204983542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983542">(Jul 25 2020 at 02:20)</a>:</h4>
<p>E.g., should I support <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>b</mi><mi>a</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_b^a f(x)\,dx=-\int_a^b f(x)\,dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.215112em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> right away, or start with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_a^b f(x)\,dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\le b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>.</p>



<a name="204983592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983592">(Jul 25 2020 at 02:22)</a>:</h4>
<p>If I'll formalize this, then I'll formalize <a href="https://en.wikipedia.org/wiki/Henstock–Kurzweil_integral">Henstock-Kurzweil</a> and McShane integrals as well.</p>



<a name="204983599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983599">(Jul 25 2020 at 02:23)</a>:</h4>
<p>Right now I'm trying to make a usable <code>interval_integral</code> based on Bochner integration.</p>



<a name="204984707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204984707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204984707">(Jul 25 2020 at 02:54)</a>:</h4>
<p>BTW, I think it's better to assume only non-strict inequalities on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> because this way your definition will work for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a=b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>.</p>



<a name="204984845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204984845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204984845">(Jul 25 2020 at 02:58)</a>:</h4>
<p>I wanted to try to do the exercises in the book, so I wanted to use the book's definition. Wouldn't that also lead to partitions like {5,5,5}?</p>



<a name="204985161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985161">(Jul 25 2020 at 03:08)</a>:</h4>
<p>what's wrong with the partition {5,5,5}?</p>



<a name="204985170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985170">(Jul 25 2020 at 03:09)</a>:</h4>
<p>Just not intuitive to me I guess.</p>



<a name="204985177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985177">(Jul 25 2020 at 03:09)</a>:</h4>
<p>i don't think it's good to wed yourself to a definition written on paper. if it's in a book that means it's battle tested as a way to get humans to learn math</p>



<a name="204985224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985224">(Jul 25 2020 at 03:10)</a>:</h4>
<p>but you should optimize your definitions to make it easy to write lean code with</p>



<a name="204985287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985287">(Jul 25 2020 at 03:12)</a>:</h4>
<p>Maybe. I'm doing this for pedagogy though.</p>



<a name="204985361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985361">(Jul 25 2020 at 03:14)</a>:</h4>
<p><code>{5, 5}</code> in a partition will add nothing to the Riemann sum, so it changes nothing.</p>



<a name="204985369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985369">(Jul 25 2020 at 03:15)</a>:</h4>
<p>But with <code>≤</code> the space of partitions has better properties.</p>



<a name="204985371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985371">(Jul 25 2020 at 03:15)</a>:</h4>
<p>E.g., you can insert a point without caring whether it's already in your set.</p>



<a name="204985380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985380">(Jul 25 2020 at 03:15)</a>:</h4>
<p>And the space of partitions of a given size is compact (not sure if it's important)</p>



<a name="204985435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985435">(Jul 25 2020 at 03:17)</a>:</h4>
<p>Sorry, I didn't mean to be adversarial. When I say you "should" do something, I just mean that I think that's the easiest path to having code that works</p>



<a name="204985448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985448">(Jul 25 2020 at 03:17)</a>:</h4>
<p>No, that's fine. I appreciate the input.</p>



<a name="204985494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985494">(Jul 25 2020 at 03:18)</a>:</h4>
<p>Also I have to remind myself every few messages that some people write Lean code for a reason different from "PR it to mathlib".</p>



<a name="204985499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985499">(Jul 25 2020 at 03:18)</a>:</h4>
<p>:)</p>



<a name="204985511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985511">(Jul 25 2020 at 03:19)</a>:</h4>
<p>No problem.</p>



<a name="204994426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204994426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204994426">(Jul 25 2020 at 08:24)</a>:</h4>
<p>Patrick your is_partition definition is not right: the implications after the colon should be and's, or moved before the colon. A structure is a better idea. I agree that &lt;= will be much easier to work with than &lt;. The theorem statements will be much neater. You'll find that the book-writers just use &lt; for psychological reasons rather than anything else. There's no harm in having rectangles of width 0. Do you have a candidate structure definition yet?</p>



<a name="204994517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204994517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204994517">(Jul 25 2020 at 08:26)</a>:</h4>
<p>I don't think n&gt;0 should be there either in is_partition,  and your quantifiers over m in nat are bad because you can't evaluate x at m. Remember x eats a term of type fin n+1 so it needs to be fed a pair consisting of a natural and a proof.</p>



<a name="205015953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205015953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205015953">(Jul 25 2020 at 18:32)</a>:</h4>
<p>The <code>n &gt; 0</code> is there to ensure that there are at least two points in the partition, <code>a</code> and <code>b</code>.</p>
<p>"Remember x eats a term of type fin n+1 so it needs to be fed a pair consisting of a natural and a proof." Does that mean that <code>x 0 = a</code> and <code>x n = b</code> are also wrong? I was following the example from earlier in the thread and Lean didn't complain. What should it be?</p>



<a name="205015985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205015985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205015985">(Jul 25 2020 at 18:33)</a>:</h4>
<p><code>a</code> and <code>b</code> should be parameters anyways since you will constantly want to quantify over partitions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>.</p>



<a name="205016006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016006">(Jul 25 2020 at 18:33)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo mathvariant="normal">≠</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \ne b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n &gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is forced anyways</p>



<a name="205016058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016058">(Jul 25 2020 at 18:34)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> then you might as well allow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> I suppose.</p>



<a name="205016129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016129">(Jul 25 2020 at 18:36)</a>:</h4>
<p>So if I want to keep the strict inequality then I should force <code>a &lt; b</code> instead?</p>



<a name="205016164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016164">(Jul 25 2020 at 18:36)</a>:</h4>
<p><code>a</code> and <code>b</code> are parameters aren't they?</p>



<a name="205016165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016165">(Jul 25 2020 at 18:36)</a>:</h4>
<p>Surely you <em>don't</em> want to force <code>a &lt; b</code> though? Isn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>a</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_a^a f(x) \, dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.215112em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> well-defined (as zero)?</p>



<a name="205016173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016173">(Jul 25 2020 at 18:37)</a>:</h4>
<p>Apparently there's a coercion from <code>nat</code> to <code>fin n</code>--I didn't realize this</p>



<a name="205016174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016174">(Jul 25 2020 at 18:37)</a>:</h4>
<p>not sure what it does on out of range inputs</p>



<a name="205016238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016238">(Jul 25 2020 at 18:38)</a>:</h4>
<p>I guess it isn't defined in this book. Interesting point.</p>



<a name="205016274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016274">(Jul 25 2020 at 18:39)</a>:</h4>
<p>What would it look like without the coercion? That is, what should <code>x 0</code> be replaced with?</p>



<a name="205016339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016339">(Jul 25 2020 at 18:41)</a>:</h4>
<p><code>x 0</code> doesn't need a coercion because <code>fin m</code> has a <code>has_zero</code> instance (I guess I don't know what happens for <code>m = 0</code> but anyways it's not possible here).</p>



<a name="205016386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016386">(Jul 25 2020 at 18:42)</a>:</h4>
<p>Otherwise, use library functions for <code>fin</code>--these were discussed above</p>



<a name="205017244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205017244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205017244">(Jul 25 2020 at 19:04)</a>:</h4>
<p>Like this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>
</code></pre></div>



<a name="205021046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021046">(Jul 25 2020 at 20:46)</a>:</h4>
<p>Note that this will work for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \le b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>. Textbooks often say something like "we can deal with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≥</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \ge b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> in the same way" but you can't do this in Lean. If you want to deal with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>1</mn><mn>0</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_1^0 f(x)\,dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.3648280000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0090080000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>, then you have (at least) three options:</p>
<ol>
<li>Support this in your definition right away. E.g., say something like <code>cmp (x m.cast_succ) (x m.succ) = cmp a b</code> in <code>h2</code>.</li>
<li><code>def integral f a b := if a ≤ b then integral_aux f a b else -integral_aux f b a</code>.</li>
<li>If <code>integral_aux f a b = 0</code> whenever <code>a ≥ b</code>, then you can also use <code>def integral f a b := integral_aux f a b - integral_aux f b a</code>.</li>
</ol>



<a name="205021051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021051">(Jul 25 2020 at 20:46)</a>:</h4>
<p>Currently I use option 3 to define <code>interval_integral</code> based on Lebesgue integral.</p>



<a name="205021064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021064">(Jul 25 2020 at 20:47)</a>:</h4>
<p>The main issue with option 2 is that you can't prove anything without <code>by_cases hab : a ≤ b</code>.</p>



<a name="205021215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021215">(Jul 25 2020 at 20:52)</a>:</h4>
<p>Option 1 gives you the correct definition right away but it's harder to prove lemmas along the way.</p>



<a name="205021275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021275">(Jul 25 2020 at 20:54)</a>:</h4>
<p>I guess a fourth option is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi>t</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\int_a^b f(x)\, dx = \int_0^1 f(a+(b-a)t)\,(b-a)dt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3648280000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0090080000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span>. But it doesn't look too good for composing intervals.</p>



<a name="205021481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021481">(Jul 25 2020 at 21:01)</a>:</h4>
<p>And option 4' is to use a partition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> in the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup></mrow><annotation encoding="application/x-tex">\int_a^b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="205021708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021708">(Jul 25 2020 at 21:07)</a>:</h4>
<p>I'm trying to define the norm of P that is <span class="tex-error">$$max_{i \leq 1 \leq n) (x_{i} - x_{i-1})$$</span>. As a starting point I have:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">norm</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="bp">...</span>
</code></pre></div>


<p>But then I don't know how to induct on the function.</p>



<a name="205021812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021812">(Jul 25 2020 at 21:10)</a>:</h4>
<p>I'd probably use <code>finset.sup</code></p>



<a name="205021864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021864">(Jul 25 2020 at 21:13)</a>:</h4>
<p>I used option 2 in metamath. You don't need to case split everything, in particular once you have additivity of endpoints you can mostly forget about this detail</p>



<a name="205021924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021924">(Jul 25 2020 at 21:15)</a>:</h4>
<p>Actually I didn't have any <code>integral_aux</code> in option 2, it was just the lebesgue integral over <code>Ioo a b</code></p>



<a name="205022071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205022071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205022071">(Jul 25 2020 at 21:19)</a>:</h4>
<p>It's actually pretty important to have this function for stating the FTC</p>



<a name="205024165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205024165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205024165">(Jul 25 2020 at 22:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205021812">said</a>:</p>
<blockquote>
<p>I'd probably use <code>finset.sup</code></p>
</blockquote>
<p>I'm not sure what you mean. Do you mean something like <code>def norm : finset ℝ → ℝ := ...</code>?</p>



<a name="205025123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205025123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205025123">(Jul 25 2020 at 22:48)</a>:</h4>
<p>i mean that <code>finset.sup</code> reduces the problem to writing an appropriate function</p>
<div class="codehilite"><pre><span></span><code><span class="n">foo</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">finset</span> <span class="err">\</span><span class="n">R</span>
</code></pre></div>


<p>and composing this with <code>finset.sup</code></p>



<a name="205027291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205027291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205027291">(Jul 25 2020 at 23:51)</a>:</h4>
<p>I'm trying option 3 with Lebesgue integral over <code>Ico a b</code>. This way you can use any measure, not only Lebesgue.</p>



<a name="205029282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029282">(Jul 26 2020 at 00:55)</a>:</h4>
<p>finset: "This file builds the basic theory of <code>finset α</code>, modelled as a <code>multiset α</code> without duplicates."<br>
Then "<code>multiset α</code> is the quotient of <code>list α</code> by list permutation. The result  is a type of finite sets with duplicates allowed."<br>
I'm lost at quotient of a list.</p>



<a name="205029333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029333">(Jul 26 2020 at 00:57)</a>:</h4>
<p>Does defining foo not still require induction on the function?</p>



<a name="205029373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029373">(Jul 26 2020 at 00:58)</a>:</h4>
<p>A multiset is a set but where repetition is allowed. In lean, it is represented by a lists modulo an equivalence relation where two lists are considered equivalent if one is a permutation of the other.</p>



<a name="205029376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029376">(Jul 26 2020 at 00:58)</a>:</h4>
<p>Quotient types are definitely a bit tricky. They're not explained until almost the very end of TPiL: <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients</a></p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> wrote a tutorial that demonstrates quotients in Lean here: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/Zmod37.lean">https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/Zmod37.lean</a></p>



<a name="205029380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029380">(Jul 26 2020 at 00:58)</a>:</h4>
<p>These are just implementation details.</p>



<a name="205029390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029390">(Jul 26 2020 at 00:59)</a>:</h4>
<p>Yeah, in practice you don't need to worry about how things are implemented</p>



<a name="205029395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029395">(Jul 26 2020 at 00:59)</a>:</h4>
<p>As long as you know how to find/use the appropriate stuff in mathlib</p>



<a name="205029398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029398">(Jul 26 2020 at 00:59)</a>:</h4>
<p>I think that's still more "in theory" than "in practice", though things are getting better all the time.</p>



<a name="205029476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029476">(Jul 26 2020 at 01:01)</a>:</h4>
<p>Let's make lots more things <code>@[irreducible]</code>! :-)</p>



<a name="205030061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030061">(Jul 26 2020 at 01:21)</a>:</h4>
<p>I can think of something like this, but replacing nat with fin n + 1, but this has a natural number to induct on (and it doesn't compile) (or terminate):</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">norm</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">norm</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
</code></pre></div>



<a name="205030325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030325">(Jul 26 2020 at 01:31)</a>:</h4>
<p>Well, this type already doesn't make much sense because what are the finite number of things you want to take the max of?</p>



<a name="205030362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030362">(Jul 26 2020 at 01:32)</a>:</h4>
<p>oh is that supposed to be the second argument?</p>



<a name="205030368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030368">(Jul 26 2020 at 01:32)</a>:</h4>
<p>That it doesn't terminate. Yeah :)</p>



<a name="205030422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030422">(Jul 26 2020 at 01:34)</a>:</h4>
<p>In general my advice is not to use induction for normal math</p>



<a name="205030423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030423">(Jul 26 2020 at 01:34)</a>:</h4>
<p>I'm not sure what your goals are though.</p>



<a name="205030437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030437">(Jul 26 2020 at 01:35)</a>:</h4>
<p>If you make a brand new recursive definition here, then you will have to prove all the lemmas about it by induction yourself.</p>



<a name="205030439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030439">(Jul 26 2020 at 01:35)</a>:</h4>
<p>Maybe that's actually what you prefer though, I don't know.</p>



<a name="205030442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030442">(Jul 26 2020 at 01:35)</a>:</h4>
<p>I'm happy not to use induction, it's confusing. I'm just not sure how to do it otherwise.</p>



<a name="205030494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030494">(Jul 26 2020 at 01:37)</a>:</h4>
<p>The best advice I have is to just read the parts of the library that seem relevant, like <code>data.finset</code>. Maybe someone else has something more specific to suggest.</p>



<a name="205030540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030540">(Jul 26 2020 at 01:38)</a>:</h4>
<p>How do you define a function on something that has a domain of the functions of type fin n + 1 to real?</p>



<a name="205030615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030615">(Jul 26 2020 at 01:40)</a>:</h4>
<p>If I had to guess, there is probably something in mathlib that gives you a <code>finset \R</code> that's the image of a map <code>fin (n+1) \to \R</code>, and something that gives you the max of a <code>finset \R</code>.</p>



<a name="205030678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030678">(Jul 26 2020 at 01:43)</a>:</h4>
<p>So, in general, I got the impression that just about everything in a functional programming language is done by some form of recursion?</p>



<a name="205030722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030722">(Jul 26 2020 at 01:44)</a>:</h4>
<p>if you want to implement these things from scratch, you'll use recursion. If you just compose functions that are already available, you can avoid it.</p>



<a name="205030795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030795">(Jul 26 2020 at 01:47)</a>:</h4>
<p>But why reimplement everything from scratch? I think in your statement "everything" only means "all elementary exercises when learning a functional programming language". :-)</p>



<a name="205030842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030842">(Jul 26 2020 at 01:48)</a>:</h4>
<p>You can use <code>(finset.univ : finset (fin n)).sup (λ j, (⟨x j.cast_succ - x j.succ, _⟩ : nnreal))</code></p>



<a name="205030851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030851">(Jul 26 2020 at 01:48)</a>:</h4>
<p>Or <code>⨆ i : fin n, x i.cast_succ - x i.succ</code></p>



<a name="205030859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030859">(Jul 26 2020 at 01:49)</a>:</h4>
<p>What is the first symbol in the second one?</p>



<a name="205030908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030908">(Jul 26 2020 at 01:51)</a>:</h4>
<p>The one that looks like a square U.</p>



<a name="205030962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030962">(Jul 26 2020 at 01:53)</a>:</h4>
<p>That's notation for max, essentially. You can copy and paste that into vscode, and hover over it to see what it is notation for. Maybe even control-click to jump to defn?</p>



<a name="205031138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031138">(Jul 26 2020 at 01:59)</a>:</h4>
<p><code>⨆ i, f i</code> is <code>mathlib</code> notation for <code>Sup (range f)</code>.</p>



<a name="205031199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031199">(Jul 26 2020 at 02:01)</a>:</h4>
<p>The relevant instance for <code>real</code>s is <code>conditionally_complete_linear_order</code>, and most theorems about <code>⨆</code> will have <code>csupr</code> in their name, and assume <code>[nonempty α]</code> and/or <code>bdd_above (range f)</code>, where <code>f : α → real</code>.</p>



<a name="205031200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031200">(Jul 26 2020 at 02:01)</a>:</h4>
<p>For empty or unbounded sets <code>Sup</code> is defined to be <code>0</code>.</p>



<a name="205031241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031241">(Jul 26 2020 at 02:02)</a>:</h4>
<p>In most cases it doesn't matter which garbage value do we use for <code>Sup empty</code> but this way a few theorems don't need <code>bdd_above</code>/<code>nonempty</code> assumption.</p>



<a name="205031290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031290">(Jul 26 2020 at 02:04)</a>:</h4>
<p>I didn't know about the control click.</p>



<a name="205031305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031305">(Jul 26 2020 at 02:05)</a>:</h4>
<p>We have both <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sup">docs#finset.sup</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.max">docs#finset.max</a></p>



<a name="205031362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031362">(Jul 26 2020 at 02:06)</a>:</h4>
<p>So <code>def norm' (n : ℕ) (x : fin (n + 1) → ℝ) := ⨆ i : fin n, x i.cast_succ - x i.succ</code>?<br>
This gives me: <code>definition 'norm'' is noncomputable, it depends on 'real.lattice.conditionally_complete_linear_order'</code></p>



<a name="205031367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031367">(Jul 26 2020 at 02:07)</a>:</h4>
<p>They have slightly different assumptions. E.g., <code>sup</code> takes a function as an argument, and for <code>max</code> you need to use <code>map</code> or <code>image</code>. Also <code>sup</code> assumes that there exists a minimal element of the type (<code>bot</code>) and <code>max</code> returns <code>none</code> for an empty <code>finset</code> and <code>some x</code> for a non-empty finset.</p>



<a name="205031368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031368">(Jul 26 2020 at 02:07)</a>:</h4>
<p>Try <code>noncomputable theory</code> at the top of your file.</p>



<a name="205031414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031414">(Jul 26 2020 at 02:08)</a>:</h4>
<p>Most probably you don't want to try developing <code>computable</code> integrals. E.g., because real numbers are noncomputable in Lean.</p>



<a name="205031483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031483">(Jul 26 2020 at 02:10)</a>:</h4>
<p>Yes, that fixed it.<br>
So I thought that if i is of type fin n, then i.cast_succ gives back i of type fin n + 1 and i.succ gives back i + 1 of type fin n + 1?</p>



<a name="205031491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031491">(Jul 26 2020 at 02:11)</a>:</h4>
<p>The "supremum" part is noncomputable.</p>



<a name="205031656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031656">(Jul 26 2020 at 02:17)</a>:</h4>
<p>(deleted)</p>



<a name="205031733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031733">(Jul 26 2020 at 02:19)</a>:</h4>
<p>The definition of norm above seems to be the other way around?</p>



<a name="205032789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205032789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205032789">(Jul 26 2020 at 02:54)</a>:</h4>
<p>So is <code>x i.cast_succ - x i.succ</code> the function passed to Sup (range f)? And i iterates over the domain of that function?</p>



<a name="205033085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033085">(Jul 26 2020 at 03:02)</a>:</h4>
<p>Yes. More precisely, the function <code>λ i : fin n, x i.cast_succ - x i.succ</code> is passed to <code>Sup (range f)</code>.</p>



<a name="205033376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033376">(Jul 26 2020 at 03:12)</a>:</h4>
<p>Cool. Am I misunderstanding the definition of cast_succ and succ? I'm guessing probably.</p>



<a name="205033434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033434">(Jul 26 2020 at 03:14)</a>:</h4>
<p><code>cast_succ</code> is just the "obvious" inclusion from <code>fin n</code> to <code>fin (n+1)</code>, while <code>succ</code> is the successor. So when you write <code>x i.cast_succ - x i.succ</code> it means, mathematically, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_i - x_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="205033446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033446">(Jul 26 2020 at 03:15)</a>:</h4>
<p>You probably want <code>i.succ - i.cast_succ</code></p>



<a name="205033449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033449">(Jul 26 2020 at 03:15)</a>:</h4>
<p>That was what I was wondering.</p>



<a name="205033499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033499">(Jul 26 2020 at 03:17)</a>:</h4>
<p>Thank you.</p>



<a name="205033501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033501">(Jul 26 2020 at 03:17)</a>:</h4>
<p>No problem!</p>



<a name="205034505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034505">(Jul 26 2020 at 03:53)</a>:</h4>
<p>In summary:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partition_norm</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>
</code></pre></div>



<a name="205034559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034559">(Jul 26 2020 at 03:55)</a>:</h4>
<p>Looks good. You can make the <code>a</code> and <code>b</code> implicit in <code>partition_norm</code> since they can be inferred from the type of <code>P</code>. You can also give the fields in partition some more descriptive names.</p>



<a name="205034607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034607">(Jul 26 2020 at 03:56)</a>:</h4>
<p>Cool.</p>



<a name="205034616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034616">(Jul 26 2020 at 03:57)</a>:</h4>
<p>If you make <code>a</code> and <code>b</code> implicit in <code>partition_norm</code>, and <code>P</code> is a partition (for some <code>a</code> and <code>b</code>) you would be able to just write <code>partition_norm P</code> for the norm of <code>P</code>.</p>



<a name="205034664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034664">(Jul 26 2020 at 03:58)</a>:</h4>
<p>Sounds good.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partition_norm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>
</code></pre></div>



<a name="205034672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034672">(Jul 26 2020 at 03:59)</a>:</h4>
<p>And if you're really up to it, look up how to write custom notation, so you can actually write something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||P||</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">∣</span><span class="mord">∣</span></span></span></span></p>



<a name="205034762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034762">(Jul 26 2020 at 04:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partition_norm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">partition_norm</span> <span class="n">P</span>
</code></pre></div>



<a name="205034847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034847">(Jul 26 2020 at 04:04)</a>:</h4>
<p>Alternatively, you can do something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">partition</span>
<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kn">end</span> <span class="n">partition</span>
</code></pre></div>


<p>which will allow you to write <code>P.norm</code> instead of <code>partition.norm P</code>.</p>



<a name="205034885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034885">(Jul 26 2020 at 04:05)</a>:</h4>
<p>Good idea.</p>



<a name="205034935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034935">(Jul 26 2020 at 04:06)</a>:</h4>
<p>One thing to keep in mind when defining notation is the precedence levels.</p>



<a name="205034986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034986">(Jul 26 2020 at 04:08)</a>:</h4>
<p>I might wait and look into that latter.</p>



<a name="205034988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034988">(Jul 26 2020 at 04:08)</a>:</h4>
<p>I need to move on to Riemann sums :)</p>



<a name="205035739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205035739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205035739">(Jul 26 2020 at 04:35)</a>:</h4>
<p>For each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>, let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo></mrow><annotation encoding="application/x-tex">x_{i}*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∗</span></span></span></span> be an arbitrary point in the interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x_{i-1}, x_{i}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">needs_a_name</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>
</code></pre></div>


<p>?</p>



<a name="205040383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205040383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205040383">(Jul 26 2020 at 07:20)</a>:</h4>
<p>I'd <code>extend</code> the original structure adding fields <code>x</code> and <code>x_mem_Icc</code></p>



<a name="205041239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205041239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205041239">(Jul 26 2020 at 07:50)</a>:</h4>
<blockquote>
<p>Cool. Am I misunderstanding the definition of cast_succ and succ? I'm guessing probably.</p>
</blockquote>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> you do know that you can just hover over a definition and see its docstring, and if it hasn't got one then you can right click on it and peek its definition, right? If you don't understand the definitions of <code>cast_succ</code> and <code>succ</code>as written in the source code then you should probably figure them out because you're going to have to get used to<code>fin m</code> at some point. A term of type <code>fin m</code> is a pair, consisting of a natural <code>i</code> and a proof that <code>i&lt;m</code>. That's all you need to know.</p>



<a name="205041311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205041311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205041311">(Jul 26 2020 at 07:53)</a>:</h4>
<p>But in general you should be able to get away with not reading definitions, and hoping that the stuff in the source code just after the definition is the interface you'll need.</p>



<a name="205041991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205041991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205041991">(Jul 26 2020 at 08:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205016129">said</a>:</p>
<blockquote>
<p>So if I want to keep the strict inequality then I should force <code>a &lt; b</code> instead?</p>
</blockquote>
<p>Re this: if you don't need that inequality, and in most places you don't, then you should go rogue and generalize the book <em>when making the definition</em> (as you did), and just insert it into the lemmas which actually need it. You'll probably be surprised to find that essentially no lemmas need it, and the authors just put this assumption in for psychological reasons. There is a big disadvantage in putting in a random assumption <code>0&lt;n</code> which is almost never needed: then every proof by induction on n, you'll have to do a fake base case, where the result is probably trivially true but the hypotheses are false anyway, and then an actual base case n=1, where the result is true but a bit less trivially, and would follow from the inductive hypothesis and the case n=0 apart from the fact that you didn't prove the n=0 case because you made the mistake of copying from the book so you can't use the n=0 case, and then an inductive step which will be the same.</p>
<p>Re finset: if you're reading the definition <code>finset</code> you're doing the wrong thing. <code>finset X</code> is the type of finite subsets of <code>X</code>. This is what you need to know. If you want to learn more about how to use <code>finset</code> then go to <code>data.finset.basic</code> and read (only) the <em>statements of the lemmas</em>. Skip the first 100-200 lines because they might be messy ones you'll never need, and then start reading from there and you'll see that the lemmas are a bunch of basic mathematical results about finite sets all of which have incomprehensible proofs which you don't need to worry about, because you are not making the <code>finset</code> API, you are just going to use it, and it's very thorough. This is all moot because it looks like you're not going to use it anyway.</p>
<p>Finally, getting the definitions right is hard. Once the definitions are there, you can start proving theorems, and it doesn't matter how messy your proofs are because they are compiled and then forgotten. But definitions you have to implement them in such a way that they are usable in practice, and it's hard for an inexperienced Lean user to set these things up. You should make a little project github repo (usnig <code>leanproject new</code>) with just one file in src for now, so you can point people to your definitions more easily. This set-up is easier to work with than one random file on your computer. <code>partition</code> and <code>partition_norm</code> are looking good but as Adam says it should be called <code>partition.norm, and your </code>h0<code>, </code>h1<code>, </code>h2` hypotheses have lousy names -- what are you -- a mathematician? Give things descriptive names. Here's what Yury means:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P</span><span class="bp">.</span><span class="n">norm</span>

<span class="kn">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>
</code></pre></div>


<p>Calling something <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and then something else <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> doesn't sound like a great idea to me. I called it <code>y</code>.</p>



<a name="205065855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205065855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205065855">(Jul 26 2020 at 20:20)</a>:</h4>
<p>Thank you. Do you have any advice for finding the things I need in mathlib? For example, I'm sure there must be a function in mathlib that allows me to easily take the sum over the range of the function on fin n, but I don't know of an easy way to find it.</p>



<a name="205066263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066263">(Jul 26 2020 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205030842">said</a>:</p>
<blockquote>
<p>You can use <code>(finset.univ : finset (fin n)).sup (λ j, (⟨x j.cast_succ - x j.succ, _⟩ : nnreal))</code><br>
Or <code>⨆ i : fin n, x i.cast_succ - x i.succ</code></p>
</blockquote>



<a name="205066333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066333">(Jul 26 2020 at 20:35)</a>:</h4>
<p>That takes the max, not the sum right?</p>



<a name="205066343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066343">(Jul 26 2020 at 20:35)</a>:</h4>
<p>Hint: it's going to be called finset.sum</p>



<a name="205066421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066421">(Jul 26 2020 at 20:37)</a>:</h4>
<p>You could do worse than read through data.finset.basic just looking at the statements of the theorems, and reading docstrings of definitions. This will give you a feeling for what's there</p>



<a name="205066472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066472">(Jul 26 2020 at 20:38)</a>:</h4>
<p>Alright.</p>



<a name="205066479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066479">(Jul 26 2020 at 20:39)</a>:</h4>
<p>you might prefer looking at it in the web browser<br>
<a href="https://leanprover-community.github.io/mathlib_docs/">https://leanprover-community.github.io/mathlib_docs/</a></p>



<a name="205066486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066486">(Jul 26 2020 at 20:39)</a>:</h4>
<p>this will automatically hide the proofs and emphasize docstrings</p>



<a name="205066535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066535">(Jul 26 2020 at 20:40)</a>:</h4>
<p>reading mathlib_docs directly is kind of like reading a book where all the proofs are exercises</p>



<a name="205066536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066536">(Jul 26 2020 at 20:40)</a>:</h4>
<p>Thanks. I didn't use finset earlier, is this a suggestion that I should have?</p>



<a name="205066542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066542">(Jul 26 2020 at 20:40)</a>:</h4>
<p>i don't know what you should do</p>



<a name="205066550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066550">(Jul 26 2020 at 20:41)</a>:</h4>
<p>if your goal is to get code reasonably quickly that expresses the mathematics you were talking about before, you should aim to take advantage of existing libraries</p>



<a name="205066559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066559">(Jul 26 2020 at 20:41)</a>:</h4>
<p>I guess that was directed to Kevin, when he said it is called finset.sum.</p>



<a name="205066621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066621">(Jul 26 2020 at 20:43)</a>:</h4>
<p>i think a literal interpretation of his words would say that kevin suggests that you find some lemma in the library called <code>finset.sum</code> or similar, literally read the statement, and try to figure out whether it applies to your situation</p>



<a name="205066635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066635">(Jul 26 2020 at 20:43)</a>:</h4>
<p>The reason I'd go for finset.sum is that the API for it is much better developed than for the other sums, or at least that was true in the past when I wanted to do finite sums</p>



<a name="205066675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066675">(Jul 26 2020 at 20:44)</a>:</h4>
<p>I see.</p>



<a name="205066679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066679">(Jul 26 2020 at 20:44)</a>:</h4>
<p>You can use finset.univ to make your finite subset of fin n</p>



<a name="205066699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066699">(Jul 26 2020 at 20:45)</a>:</h4>
<p>And if you read the relevant part of the finset API (and Jalex is right, you'd be much better off reading the docs than the source code) then you'd see it in action and also what the basic lemmas are</p>



<a name="205066755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066755">(Jul 26 2020 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205066635">said</a>:</p>
<blockquote>
<p>The reason I'd go for finset.sum is that the API for it is much better developed than for the other sums, or at least that was true in the past when I wanted to do finite sums</p>
</blockquote>
<p>And it has a nice notation too</p>



<a name="205066764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066764">(Jul 26 2020 at 20:46)</a>:</h4>
<p>Which hopefully you'll see in the docs. Is it used there?</p>



<a name="205066841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066841">(Jul 26 2020 at 20:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html">https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html</a></p>



<a name="205066852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066852">(Jul 26 2020 at 20:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html#finset.sum">https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html#finset.sum</a></p>



<a name="205066905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066905">(Jul 26 2020 at 20:50)</a>:</h4>
<p>Start there and go down and hopefully you'll see enough to figure how to use this stuff</p>



<a name="205066978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066978">(Jul 26 2020 at 20:52)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathematics_in_lean/">#mil</a> should cover all this too, eventually.</p>



<a name="205080287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080287">(Jul 27 2020 at 04:03)</a>:</h4>
<p>I wonder if it would be helpful to have examples of use in the mathlib documentation. It might help me.</p>



<a name="205080417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080417">(Jul 27 2020 at 04:07)</a>:</h4>
<p>Yes, I would support that. There are some usage examples in the docstrings in <a href="https://leanprover-community.github.io/mathlib_docs/data/list/defs.html"><code>data.list.defs</code></a>, but very few elsewhere. Contributions are welcome!</p>



<a name="205080463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080463">(Jul 27 2020 at 04:08)</a>:</h4>
<p>I would contribute if I knew how to use them. :)</p>



<a name="205080582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080582">(Jul 27 2020 at 04:12)</a>:</h4>
<p>You can search mathlib itself for usage examples, sometimes that helps. But of course, questions here are always welcome too!</p>



<a name="205549886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205549886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205549886">(Jul 31 2020 at 01:26)</a>:</h4>
<p>This compiles:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">y</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">))</span>
</code></pre></div>


<p>I'm not sure I understand what finset.univ does.</p>
<p>If I try this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span>
</code></pre></div>


<p>then I get 'unexpected token' for the summation symbol. I have tried various imports, but have not found one that fixes it.</p>



<a name="205550110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205550110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205550110">(Jul 31 2020 at 01:32)</a>:</h4>
<p>Did you try <code>open_locale big_operators</code>?</p>



<a name="205550214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205550214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205550214">(Jul 31 2020 at 01:35)</a>:</h4>
<p>If I put that in front of the definition then I get a command expected error. Entire file:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="c1">-- := ⨆ i : fin P.n, P.x i.succ - P.x i.cast_succ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P</span><span class="bp">.</span><span class="n">norm</span>

<span class="kn">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">def riemann_sum (a b : ℝ) (P : pointed_partition a b) (f : ℝ → ℝ) : ℝ</span>
<span class="cm">:= (finset.univ : finset (fin P.n)).sum (λ i, f (P.y i) * (P.x i.succ - P.x i.cast_succ))</span>
<span class="cm">-/</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span>
</code></pre></div>



<a name="205552123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205552123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205552123">(Jul 31 2020 at 02:22)</a>:</h4>
<p>the first error in the file is significantly before the definition of riemann sum</p>



<a name="205552538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205552538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205552538">(Jul 31 2020 at 02:35)</a>:</h4>
<p>Yeah the notation for Sum needs some arguments after it.</p>



<a name="205553002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205553002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205553002">(Jul 31 2020 at 02:48)</a>:</h4>
<p>So this should be what you want i think:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">y</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span>
</code></pre></div>



<a name="205554546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205554546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205554546">(Jul 31 2020 at 03:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205552123">said</a>:</p>
<blockquote>
<p>the first error in the file is significantly before the definition of riemann sum</p>
</blockquote>
<p>Yeah, it was fine in Visual Studio Code, but when I pasted it into the lean web page it gave a bunch of errors. I'm updating my OS, etc. now.</p>



<a name="205554916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205554916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205554916">(Jul 31 2020 at 03:38)</a>:</h4>
<p>I think I had to add the import <code>data.fintype.basic</code> to makee it work on my mathlib</p>



<a name="205555025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555025">(Jul 31 2020 at 03:41)</a>:</h4>
<p>In the web editor I get <code>file 'data/fintype/basic' not found in the LEAN_PATH</code>.</p>



<a name="205555093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555093">(Jul 31 2020 at 03:43)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%20data.set.intervals%20data.finset%20algebra.big_operators%20data.fintype.basic%0A%0Anoncomputable%20theory%0A%0Astructure%20partition%20%28a%20%3A%20%E2%84%9D%29%20%28b%20%3A%20%E2%84%9D%29%20%3A%3D%0A%28n%20%3A%20%E2%84%95%29%0A%28x%20%3A%20fin%20%28n%20%2B%201%29%20%E2%86%92%20%E2%84%9D%29%0A%28x_zero%20%3A%20x%200%20%3D%20a%29%0A%28x_last%20%3A%20x%20%28fin.last%20n%29%20%3D%20b%29%0A%28mono%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20x%20m.cast_succ%20%E2%89%A4%20x%20m.succ%29%0A%0Anamespace%20partition%0A%0Adef%20norm%20%7Ba%20b%20%3A%20%E2%84%9D%7D%20%28P%20%3A%20partition%20a%20b%29%20%3A%20%E2%84%9D%0A--%20%3A%3D%20%E2%A8%86%20i%20%3A%20fin%20P.n%2C%20P.x%20i.succ%20-%20P.x%20i.cast_succ%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sup%20%28%CE%BB%20j%2C%20%28P.x%20j.cast_succ%20-%20P.x%20j.succ%29%29%0A%0Anotation%20%60%7C%7C%60P%60%7C%7C%60%20%3A%3D%20P.norm%0A%0Aend%20partition%0A%0Aopen%20set%0A%0Astructure%20pointed_partition%20%28a%20b%20%3A%20%E2%84%9D%29%20extends%20partition%20a%20b%20%3A%3D%0A%28y%20%3A%20fin%20n%20%E2%86%92%20%E2%84%9D%29%0A%28mem_block%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20y%20m%20%E2%88%88%20Icc%20%28x%20m.cast_succ%29%20%28x%20m.succ%29%29%0A%0Ainstance%20%28a%20b%20%3A%20%E2%84%9D%29%20%3A%20has_coe_to_fun%20%28pointed_partition%20a%20b%29%20%3A%3D%20%E2%9F%A8_%2C%20%CE%BB%20c%2C%20c.y%E2%9F%A9%0A%0A%2F-%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sum%20%28%CE%BB%20i%2C%20f%20%28P.y%20i%29%20*%20%28P.x%20i.succ%20-%20P.x%20i.cast_succ%29%29%0A-%2F%0A%0Aopen_locale%20big_operators%0A%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%E2%88%91%20n%2C%20f%20%28P%20n%29%20*%20%28P.x%20n.succ%20-%20P.x%20n.cast_succ%29%0A%0A%23print%20riemann_sum">https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%20data.set.intervals%20data.finset%20algebra.big_operators%20data.fintype.basic%0A%0Anoncomputable%20theory%0A%0Astructure%20partition%20%28a%20%3A%20%E2%84%9D%29%20%28b%20%3A%20%E2%84%9D%29%20%3A%3D%0A%28n%20%3A%20%E2%84%95%29%0A%28x%20%3A%20fin%20%28n%20%2B%201%29%20%E2%86%92%20%E2%84%9D%29%0A%28x_zero%20%3A%20x%200%20%3D%20a%29%0A%28x_last%20%3A%20x%20%28fin.last%20n%29%20%3D%20b%29%0A%28mono%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20x%20m.cast_succ%20%E2%89%A4%20x%20m.succ%29%0A%0Anamespace%20partition%0A%0Adef%20norm%20%7Ba%20b%20%3A%20%E2%84%9D%7D%20%28P%20%3A%20partition%20a%20b%29%20%3A%20%E2%84%9D%0A--%20%3A%3D%20%E2%A8%86%20i%20%3A%20fin%20P.n%2C%20P.x%20i.succ%20-%20P.x%20i.cast_succ%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sup%20%28%CE%BB%20j%2C%20%28P.x%20j.cast_succ%20-%20P.x%20j.succ%29%29%0A%0Anotation%20%60%7C%7C%60P%60%7C%7C%60%20%3A%3D%20P.norm%0A%0Aend%20partition%0A%0Aopen%20set%0A%0Astructure%20pointed_partition%20%28a%20b%20%3A%20%E2%84%9D%29%20extends%20partition%20a%20b%20%3A%3D%0A%28y%20%3A%20fin%20n%20%E2%86%92%20%E2%84%9D%29%0A%28mem_block%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20y%20m%20%E2%88%88%20Icc%20%28x%20m.cast_succ%29%20%28x%20m.succ%29%29%0A%0Ainstance%20%28a%20b%20%3A%20%E2%84%9D%29%20%3A%20has_coe_to_fun%20%28pointed_partition%20a%20b%29%20%3A%3D%20%E2%9F%A8_%2C%20%CE%BB%20c%2C%20c.y%E2%9F%A9%0A%0A%2F-%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sum%20%28%CE%BB%20i%2C%20f%20%28P.y%20i%29%20*%20%28P.x%20i.succ%20-%20P.x%20i.cast_succ%29%29%0A-%2F%0A%0Aopen_locale%20big_operators%0A%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%E2%88%91%20n%2C%20f%20%28P%20n%29%20*%20%28P.x%20n.succ%20-%20P.x%20n.cast_succ%29%0A%0A%23print%20riemann_sum</a></p>



<a name="205555132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555132">(Jul 31 2020 at 03:44)</a>:</h4>
<p>works fine for me except it doesn't like your definition of norm, as it needs a bottom element for when the set is empty</p>



<a name="205555194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555194">(Jul 31 2020 at 03:46)</a>:</h4>
<p>A possible solution is to make <code>(P.x j.cast_succ - P.x j.succ)</code> land in nnreal so that the bottom element is 0.</p>



<a name="205555198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555198">(Jul 31 2020 at 03:46)</a>:</h4>
<p>Huh, that is a different web editor than the one I was using. I get a failed to synthesize error on this line <code>:= (finset.univ : finset (fin P.n)).sup (λ j, (P.x j.cast_succ - P.x j.succ))</code> in that.</p>



<a name="205555258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555258">(Jul 31 2020 at 03:48)</a>:</h4>
<p>Yeah always use the community web editor!</p>



<a name="205555272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555272">(Jul 31 2020 at 03:49)</a>:</h4>
<p>And yes that's the error I'm talking about, if you want to take sup over a set the Type the set is valued in needs to have an infimum or bottom element so that if you take the sup of the empty set you get a decent value back.</p>



<a name="205555541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555541">(Jul 31 2020 at 03:56)</a>:</h4>
<p>So I need a case for when <code>(finset.univ : finset (fin P.n))</code> is empty?</p>



<a name="205555709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555709">(Jul 31 2020 at 04:00)</a>:</h4>
<p>Yeah or you can use max instead of sup, which returns <code>none</code> if the input is empty, so your norm would land in <code>option real</code> instead of <code>real</code>. But I think the <code>nnreal</code> way is nicer.</p>



<a name="205555789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555789">(Jul 31 2020 at 04:03)</a>:</h4>
<p>Actually I just tried to do this and noticed that your norm is negatively valued!</p>



<a name="205555855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555855">(Jul 31 2020 at 04:05)</a>:</h4>
<p>I guess that's not intentional so I switched it to this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">nnreal</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>
<span class="n">open_locale</span> <span class="n">nnreal</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span>
<span class="c1">-- := ⨆ i : fin P.n, P.x i.succ - P.x i.cast_succ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">mono</span> <span class="n">P</span> <span class="n">j</span><span class="o">]</span><span class="bp">⟩</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P</span><span class="bp">.</span><span class="n">norm</span>

<span class="kn">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="bp">.</span><span class="n">y</span><span class="bp">⟩</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">def riemann_sum (a b : ℝ) (P : pointed_partition a b) (f : ℝ → ℝ) : ℝ</span>
<span class="cm">:= (finset.univ : finset (fin P.n)).sum (λ i, f (P.y i) * (P.x i.succ - P.x i.cast_succ))</span>
<span class="cm">-/</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">riemann_sum</span>
</code></pre></div>



<a name="205556027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556027">(Jul 31 2020 at 04:10)</a>:</h4>
<p>There is a proof in the definition?</p>



<a name="205556090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556090">(Jul 31 2020 at 04:12)</a>:</h4>
<p>Yep, to give an element of the nonnegative reals (ℝ≥0)  we give an element of  <code>ℝ</code> and a proof that it is nonnegative, as this is defined as a subtype in lean.</p>



<a name="205556191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556191">(Jul 31 2020 at 04:15)</a>:</h4>
<p>I see.</p>



<a name="205556899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556899">(Jul 31 2020 at 04:33)</a>:</h4>
<p>Why does making it nnreal satisfy the need for an empty case?</p>



<a name="205556955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556955">(Jul 31 2020 at 04:34)</a>:</h4>
<p>Because the nnreal are bounded below and hence have a sup?</p>



<a name="205556960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556960">(Jul 31 2020 at 04:34)</a>:</h4>
<p>Actually an inf right?</p>



<a name="205556974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556974">(Jul 31 2020 at 04:35)</a>:</h4>
<p>Yeah exactly, because nnreal has a smallest element (0) so that when you give an empty set the supremum has something sensible to be. You would want reals with  a negative infinity if you really wanted values in reals, but as your terms are all positive this seemed cleaner</p>



<a name="205557039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205557039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205557039">(Jul 31 2020 at 04:37)</a>:</h4>
<p>So the sup of an empty subset of the nnreals is 0?</p>



<a name="205557054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205557054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205557054">(Jul 31 2020 at 04:37)</a>:</h4>
<p>Is that by convention?</p>



<a name="205557257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205557257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205557257">(Jul 31 2020 at 04:42)</a>:</h4>
<p>No, I guess that makes sense. Every nnreal is an upper bound, so the least of those is 0.</p>



<a name="205701761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701761">(Aug 01 2020 at 23:00)</a>:</h4>
<p>As an aside, does this make sense? Is using structures like this a reasonable way to define the upper bound and the least upper bound?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">not</span> <span class="n">is_ub</span><span class="o">)</span>
</code></pre></div>



<a name="205701827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701827">(Aug 01 2020 at 23:02)</a>:</h4>
<p>You mean</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>


<p>&amp; similarly for <code>lub</code></p>



<a name="205701874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701874">(Aug 01 2020 at 23:04)</a>:</h4>
<p>If I take out the Prop it seems to break the use of is_ub in the definition of lub.</p>



<a name="205701881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701881">(Aug 01 2020 at 23:04)</a>:</h4>
<p>oh yes, I didn't notice that part is separately wrong.</p>



<a name="205701886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701886">(Aug 01 2020 at 23:05)</a>:</h4>
<p>What did I do wrong?</p>



<a name="205701899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701899">(Aug 01 2020 at 23:05)</a>:</h4>
<p>It just doesn't make any sense.</p>



<a name="205701902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701902">(Aug 01 2020 at 23:05)</a>:</h4>
<p><code>:=</code> is for default values, it's rarely useful.</p>



<a name="205701906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701906">(Aug 01 2020 at 23:05)</a>:</h4>
<p>You need to replace it with what it means to be a least upper bound</p>



<a name="205701951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701951">(Aug 01 2020 at 23:06)</a>:</h4>
<p>So I want to say that the ub and the lub are real numbers. That is done by the t : \real right?</p>



<a name="205701966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701966">(Aug 01 2020 at 23:07)</a>:</h4>
<p>In <code>ub</code> you're saying (with the corrected version) that an upper bound of a set <code>S</code> is a real number <code>t</code> such that <code>∀ s ∈ S, s ≤ t</code>.</p>



<a name="205701968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701968">(Aug 01 2020 at 23:07)</a>:</h4>
<p>Which is right.</p>



<a name="205702011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702011">(Aug 01 2020 at 23:08)</a>:</h4>
<p>The original said that an upper bound is any real number <code>t</code> together with any proposition which, if you don't supply it, defaults to <code>∀ s ∈ S, s ≤ t</code>.</p>



<a name="205702017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702017">(Aug 01 2020 at 23:09)</a>:</h4>
<p>I see. Ok. So now I'm not sure how to make use of the is_ub in the lub. I tried not is_ub r, but that doesn't seem to work.</p>



<a name="205702021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702021">(Aug 01 2020 at 23:09)</a>:</h4>
<p>You don't need to make use of it</p>



<a name="205702027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702027">(Aug 01 2020 at 23:09)</a>:</h4>
<p>True. I thought it might be easier to read though.</p>



<a name="205702030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702030">(Aug 01 2020 at 23:09)</a>:</h4>
<p>Maybe start with the definition in math?</p>



<a name="205702035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702035">(Aug 01 2020 at 23:10)</a>:</h4>
<p>(you also can't use it in any sensible way)</p>



<a name="205702073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702073">(Aug 01 2020 at 23:10)</a>:</h4>
<p>I mean, since the structure already contains the field <code>is_ub</code> you don't need to repeat the fact that it is an upper bound in the fact that it is a <em>least</em> upper bound, I guess.</p>



<a name="205702127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702127">(Aug 01 2020 at 23:12)</a>:</h4>
<p>That isn't how I wanted to use it. I can write:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">))</span>
</code></pre></div>


<p>but the last part is just stating that r is not an ub.</p>



<a name="205702131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702131">(Aug 01 2020 at 23:12)</a>:</h4>
<p>ub of S that is.</p>



<a name="205702189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702189">(Aug 01 2020 at 23:15)</a>:</h4>
<p>These extra <code>¬</code>s are a little awkward (normal definition would be that if <code>r</code> is another upper bound, then <code>t &lt;= r</code>) but that works.</p>



<a name="205702198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702198">(Aug 01 2020 at 23:15)</a>:</h4>
<p>You could also reuse the whole structure <code>ub</code></p>



<a name="205702248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702248">(Aug 01 2020 at 23:16)</a>:</h4>
<p>What do you mean by reuse the whole structure ub?</p>



<a name="205702363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702363">(Aug 01 2020 at 23:20)</a>:</h4>
<p>Quantify over all <code>ub S</code> in the type of <code>is_lub</code>, rather than writing out the two hypotheses separately</p>



<a name="205702370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702370">(Aug 01 2020 at 23:21)</a>:</h4>
<p>Also, you might not really want a structure in the first place.</p>



<a name="205702415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702415">(Aug 01 2020 at 23:22)</a>:</h4>
<p>mathlib style is more like <code>def is_ub (S : set \R) (t : \R) : Prop := \all s \in S, s \le t</code> and <code>def is_lub (S : set \R) (t : \R) : Prop := ...</code> (can use <code>is_ub</code>).</p>



<a name="205702428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702428">(Aug 01 2020 at 23:23)</a>:</h4>
<p>I thought it might make things cleaner to say r : ub S, then both r : real and is_ub r S. It would look closer to proofs on paper.</p>



<a name="205702471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702471">(Aug 01 2020 at 23:24)</a>:</h4>
<p>If I try to do:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="c1">--(is_lub : ∀ r : ℝ, r &lt; t → ¬ (∀ s ∈ S, s ≤ r))</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ub</span> <span class="n">S</span><span class="o">,</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>


<p>I get an error on the last leq.</p>



<a name="205702482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702482">(Aug 01 2020 at 23:25)</a>:</h4>
<p>abomination incoming:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
<span class="o">(</span><span class="n">t_is_ub</span> <span class="o">:</span> <span class="n">is_ub</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">not</span> <span class="n">is_ub</span><span class="o">)</span>
<span class="o">(</span><span class="n">t_is_lub</span> <span class="o">:</span> <span class="n">is_lub</span><span class="o">)</span>
</code></pre></div>



<a name="205702483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702483">(Aug 01 2020 at 23:25)</a>:</h4>
<p>that's because <code>r : ub S</code> and not <code>r : \R</code></p>



<a name="205702486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702486">(Aug 01 2020 at 23:25)</a>:</h4>
<p>you would have to write <code>r.t</code> instead</p>



<a name="205702529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702529">(Aug 01 2020 at 23:26)</a>:</h4>
<p>What does r.t mean?</p>



<a name="205702530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702530">(Aug 01 2020 at 23:26)</a>:</h4>
<p><code>ub.t r</code></p>



<a name="205702532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702532">(Aug 01 2020 at 23:26)</a>:</h4>
<p>i.e. the <code>t</code> field</p>



<a name="205702533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702533">(Aug 01 2020 at 23:26)</a>:</h4>
<p>Oh.</p>



<a name="205702539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702539">(Aug 01 2020 at 23:27)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



<a name="205702540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702540">(Aug 01 2020 at 23:27)</a>:</h4>
<p>Ch. 9</p>



<a name="205702587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702587">(Aug 01 2020 at 23:28)</a>:</h4>
<p>I don't really think the bundled structure is more like informal math. The big difference from informal math is in Lean you're generally forced to refer to statements you know (like "<code>r</code> is an upper bound of <code>S</code>") explicitly somehow--whether that statement is called <code>r.is_ub</code> or <code>h</code>, you still have to name it.</p>



<a name="205702637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702637">(Aug 01 2020 at 23:30)</a>:</h4>
<p>The disadvantage of the structure is that it forces you to introduce both <code>r</code> and the hypothesis that it is the (least) upper bound of something simultaneously--if you already had an <code>r</code> you were interested in then you have to jump through extra hoops to just state that it is an upper bound.</p>



<a name="205702641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702641">(Aug 01 2020 at 23:30)</a>:</h4>
<p>Why was it better to use a structure for the definition of a partition instead of saying is_partition?</p>



<a name="205702656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702656">(Aug 01 2020 at 23:31)</a>:</h4>
<p>It's not necessarily better or worse</p>



<a name="205702657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702657">(Aug 01 2020 at 23:31)</a>:</h4>
<p>just different</p>



<a name="205702701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702701">(Aug 01 2020 at 23:32)</a>:</h4>
<p>But, it's probably not as frequent in math that you have a random collection of subsets of a set lying around and you want to talk about whether or not it is a partition</p>



<a name="205702707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702707">(Aug 01 2020 at 23:32)</a>:</h4>
<p>but it does seem quite likely that you would have a random real number lying around and want to talk about whether or not it is an upper bound</p>



<a name="205702713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702713">(Aug 01 2020 at 23:33)</a>:</h4>
<p>For example with the structure <code>ub</code> alone it's quite awkward to express "<code>t</code> is not an upper bound of <code>S</code>"</p>



<a name="205702722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702722">(Aug 01 2020 at 23:33)</a>:</h4>
<p>I see.</p>



<a name="205702764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702764">(Aug 01 2020 at 23:34)</a>:</h4>
<p>And somehow, talking about something not being an upper bound feels plausible in a way that talking about something not being a partition does not</p>



<a name="205702771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702771">(Aug 01 2020 at 23:35)</a>:</h4>
<p>I believe the correct answer is "you'll know which implementation is better as you go on proving things about it"</p>



<a name="205702818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702818">(Aug 01 2020 at 23:36)</a>:</h4>
<p>you want to say, if <code>s</code> is an LUB of <code>A</code> and <code>t</code> of <code>B</code> then <code>s+t</code> of <code>A+B</code></p>



<a name="205702821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702821">(Aug 01 2020 at 23:36)</a>:</h4>
<p>which means the implementation without structure is better</p>



<a name="205702887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702887">(Aug 01 2020 at 23:39)</a>:</h4>
<p>Alright. Just out of pure curiosity, is there a way to replace the ¬ ∀ s ∈ S, s ≤ t with the simpler statement that r is not an ub as previously defined?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="c1">-- upper bound</span>
<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="c1">-- least upper bound</span>
<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>



<a name="205702991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702991">(Aug 01 2020 at 23:42)</a>:</h4>
<p>I imagine a similar question might come up in the definition of something else as a structure that makes more sense.</p>



<a name="205703013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703013">(Aug 01 2020 at 23:43)</a>:</h4>
<p>you can say "there does not exist a <code>ub</code> whose <code>t</code> equals the given <code>t</code>"</p>



<a name="205703019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703019">(Aug 01 2020 at 23:43)</a>:</h4>
<p>but as I mentioned above it's awkward</p>



<a name="205703021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703021">(Aug 01 2020 at 23:44)</a>:</h4>
<p>this awkwardness would disappear with the usual definition</p>



<a name="205703064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703064">(Aug 01 2020 at 23:44)</a>:</h4>
<p>Alright.</p>



<a name="205703067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703067">(Aug 01 2020 at 23:44)</a>:</h4>
<p>Thank you.</p>



<a name="205703220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703220">(Aug 01 2020 at 23:50)</a>:</h4>
<p>Since we can prove the lub is unique, is a there a way to say the lub S instead of t is_lub S without the structure?</p>



<a name="205703382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703382">(Aug 01 2020 at 23:57)</a>:</h4>
<p>I end up defining things named lub_S to keep track that they are the lub of S. Just hoping there was a simpler way.</p>



<a name="205703540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703540">(Aug 02 2020 at 00:03)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="err">$</span> <span class="n">is_lub</span> <span class="n">S</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="205703591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703591">(Aug 02 2020 at 00:04)</a>:</h4>
<p>What does classical.epsilon $ is_lub S mean?</p>



<a name="205703602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703602">(Aug 02 2020 at 00:05)</a>:</h4>
<p><code>is_lub S</code> is a predicate on <code>\R</code></p>



<a name="205703605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703605">(Aug 02 2020 at 00:05)</a>:</h4>
<p><code>classical.epsilon</code> means, if there's some <code>r : \R</code> satisfying it, return <code>r</code></p>



<a name="205703606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703606">(Aug 02 2020 at 00:05)</a>:</h4>
<p>otherwise return a default element</p>



<a name="205703712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703712">(Aug 02 2020 at 00:09)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">},</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="err">$</span> <span class="n">is_lub</span> <span class="n">S</span>

<span class="kn">theorem</span> <span class="n">is_lub_unique</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">t₁</span> <span class="n">t₂</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht₁</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">t₁</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">ht₁</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">eq_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">lub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">is_lub_unique</span> <span class="n">ht</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">epsilon_spec</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="205703717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703717">(Aug 02 2020 at 00:09)</a>:</h4>
<p>any this is the API for <code>lub</code></p>



<a name="205703719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703719">(Aug 02 2020 at 00:09)</a>:</h4>
<p>so you can forget about its definition</p>



<a name="205703779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703779">(Aug 02 2020 at 00:11)</a>:</h4>
<p>What would happen if I used lub S in a proof, and one didn't exist? Would I get an error in Lean?</p>



<a name="205703824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703824">(Aug 02 2020 at 00:12)</a>:</h4>
<p>did you read the definition of <code>lub</code>? did you put it in your VSCode? do you know what classical.epsilon is?</p>



<a name="205703877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703877">(Aug 02 2020 at 00:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205703606">said</a>:</p>
<blockquote>
<p>otherwise return a default element</p>
</blockquote>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span></p>



<a name="205703884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703884">(Aug 02 2020 at 00:14)</a>:</h4>
<p>you wouldn't get any error</p>



<a name="205703885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703885">(Aug 02 2020 at 00:14)</a>:</h4>
<p>but you wouldn't be able to prove anything about it in that case</p>



<a name="205703893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703893">(Aug 02 2020 at 00:15)</a>:</h4>
<p>treat it as an unspecified constant</p>



<a name="205703896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703896">(Aug 02 2020 at 00:15)</a>:</h4>
<p>I guess it isn't any different than saying t is_lub S. The assumption that t exists is in the statement.</p>



<a name="205703947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703947">(Aug 02 2020 at 00:16)</a>:</h4>
<p>Why wouldn't I be able to prove anything about it?</p>



<a name="205704001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704001">(Aug 02 2020 at 00:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205703824">said</a>:</p>
<blockquote>
<p>did you read the definition of <code>lub</code>? did you put it in your VSCode? do you know what classical.epsilon is?</p>
</blockquote>
<p>Yes, but did not understand the result.</p>



<a name="205704064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704064">(Aug 02 2020 at 00:21)</a>:</h4>
<p>ah, it looks like the docstring for classical.epsilon just tells you the math name for the concept</p>



<a name="205704167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704167">(Aug 02 2020 at 00:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205703947">said</a>:</p>
<blockquote>
<p>Why wouldn't I be able to prove anything about it?</p>
</blockquote>
<p>because it has no definition</p>



<a name="205704168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704168">(Aug 02 2020 at 00:24)</a>:</h4>
<p>it uses <code>classical.choice</code></p>



<a name="205704170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704170">(Aug 02 2020 at 00:24)</a>:</h4>
<p>which produces an element of any type <code>A</code> from a proof of <code>nonempty A</code> by fiat</p>



<a name="205704406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704406">(Aug 02 2020 at 00:32)</a>:</h4>
<p>(deleted)</p>



<a name="205704526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704526">(Aug 02 2020 at 00:37)</a>:</h4>
<p>I'm not sure I entirely follow. I guess my worry is that it is something like the definition of 0 - 1 = 0 if 0 and 1 are natural numbers. That is, I might prove something that I didn't expect I could.</p>



<a name="205704571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704571">(Aug 02 2020 at 00:38)</a>:</h4>
<p>if <code>S</code> doesn't have an LUB, then <code>lub S</code> will be some real number whose value is outside of your knowledge</p>



<a name="205704573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704573">(Aug 02 2020 at 00:38)</a>:</h4>
<p>it will behave like an arbiratry real number</p>



<a name="205704628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704628">(Aug 02 2020 at 00:40)</a>:</h4>
<p>I guess it isn't much different than saying t is_lub S then?</p>



<a name="205704631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704631">(Aug 02 2020 at 00:40)</a>:</h4>
<p>That is <code>t : \R</code> and <code>t is_lub S</code>.</p>



<a name="205704640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704640">(Aug 02 2020 at 00:41)</a>:</h4>
<p>Or is it actually safer?</p>



<a name="205704686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704686">(Aug 02 2020 at 00:42)</a>:</h4>
<p>Because the arbitrary number won't have the properties of the lub to use?</p>



<a name="205705628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205705628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205705628">(Aug 02 2020 at 01:16)</a>:</h4>
<p>How do I get at the properties of lub S? That is, use the fact that it is an ub of S and it is leq to any ub of S in a proof.</p>



<a name="205709698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205709698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205709698">(Aug 02 2020 at 03:34)</a>:</h4>
<p>I guess I need to prove: <code>example (S : set ℝ) : is_lub S (lub S) :=</code> ?</p>



<a name="205709765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205709765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205709765">(Aug 02 2020 at 03:36)</a>:</h4>
<p>that would mean every set has lub</p>



<a name="205709877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205709877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205709877">(Aug 02 2020 at 03:41)</a>:</h4>
<p>How do I get at the properties of lub S?</p>



<a name="205716405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205716405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205716405">(Aug 02 2020 at 07:32)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">},</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="err">$</span> <span class="n">is_lub</span> <span class="n">S</span>

<span class="kn">theorem</span> <span class="n">is_lub_unique</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">t₁</span> <span class="n">t₂</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht₁</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">t₁</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">ht₁</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">is_lub_lub</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="o">(</span><span class="n">lub</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon_spec</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">eq_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">lub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">is_lub_unique</span> <span class="n">ht</span> <span class="err">$</span> <span class="n">is_lub_lub</span> <span class="n">ht</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="205716406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205716406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205716406">(Aug 02 2020 at 07:32)</a>:</h4>
<p>is this enough API?</p>



<a name="205716407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205716407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205716407">(Aug 02 2020 at 07:32)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span></p>



<a name="205737796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205737796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205737796">(Aug 02 2020 at 18:15)</a>:</h4>
<p>Thank you!</p>



<a name="205930211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205930211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Shapero <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205930211">(Aug 04 2020 at 16:43)</a>:</h4>
<p>I was curious about defining Riemann integration and started experimenting with it as well -- I was wondering whether it might be easier to define partitions as a vector of real numbers rather than a mapping from <code>fin</code>? If it's a vector, you can easily pull in some of the existing machinery for sorting lists; for example merging two partitions just reduces to a single library call</p>



<a name="206189521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206189521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206189521">(Aug 06 2020 at 20:00)</a>:</h4>
<p>That sounds simpler. I don't know though, I'm new at this.</p>



<a name="206318611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206318611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206318611">(Aug 07 2020 at 23:04)</a>:</h4>
<p>I would also be interested in hearing opinions on this.</p>



<a name="206321731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206321731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206321731">(Aug 08 2020 at 00:04)</a>:</h4>
<p>It may just largely be a matter of preference. After having used <code>fin</code> for one proof I realize that you need to have everything set up very well from the very beginning in order not to bump into nasty coercion problems. For people with computational background thinking in terms of <code>vector</code> will probably seem more natural. I'm curious what other people with more Lean experience have to say, but it's good to bear in mind that the interface/API (i.e. for <code>fin</code> and <code>vector</code>) is of utmost importance. Also, I don't think you'll have to "sort" in the classical computer-science meaning of the term, where you really handle list/vector elements (like in a "quicksort" algorithm, say). You'll just be dealing with proofs that your sequences are <code>monotone</code>.</p>



<a name="206329453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206329453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206329453">(Aug 08 2020 at 03:36)</a>:</h4>
<p>I'm trying to fill in the first sorry in this theorem. By using a rewrite and <code>set.​mem_set_of_eq</code> I can get to<code>z ∈ Z = ∃ x ∈ X, ∃ y ∈ Y, z = x + y</code>, but then I get stuck. I'm wondering it it would be simpler if I had stated the theorem differently, but I'm not sure how.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≥</span> <span class="n">t</span><span class="o">)</span>


<span class="kn">theorem</span> <span class="n">sum_of_lub</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">Z</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">})</span>
<span class="o">:</span> <span class="n">is_lub</span> <span class="n">Z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">Z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">Z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s10</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">s10</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s100</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">s100</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206330050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206330050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206330050">(Aug 08 2020 at 03:57)</a>:</h4>
<p>I guess finish works. I don't understand the description of finish though.</p>



<a name="206333403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206333403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206333403">(Aug 08 2020 at 05:42)</a>:</h4>
<p>I'm not sure what I have done wrong here:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>


<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≥</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">example</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">Z</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">})</span>
<span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">Z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">Z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">s2</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">x&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">y&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">X</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h0</span><span class="bp">.</span><span class="n">elim_left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">s4</span> <span class="n">x&#39;</span> <span class="n">a2</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span><span class="bp">.</span><span class="n">elim_left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">s6</span> <span class="n">y&#39;</span> <span class="n">a3</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span>
  <span class="o">)</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206334756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334756">(Aug 08 2020 at 06:26)</a>:</h4>
<p><code>(Z = {z | ∃ x ∈ X, ∃ y ∈ Y, z = x + y})</code> is just incorrect</p>



<a name="206334790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334790">(Aug 08 2020 at 06:27)</a>:</h4>
<p>ok, incorrect is a bit strong, but it doesn't have its intended meaning?</p>



<a name="206334833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334833">(Aug 08 2020 at 06:28)</a>:</h4>
<p>Lean treats it as <code>(Z) (H : Z = {z | ∃ x ∈ X, ∃ y ∈ Y, z = x + y})</code></p>



<a name="206334840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334840">(Aug 08 2020 at 06:28)</a>:</h4>
<p>which I guess still works</p>



<a name="206335059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206335059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206335059">(Aug 08 2020 at 06:35)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pointwise</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">s</span><span class="o">⦄,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span> <span class="c1">-- implicit argument</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">⦄,</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span> <span class="c1">-- we prefer `≤`; extra bracket removed; implicit</span>

<span class="kn">theorem</span> <span class="n">is_lub_add</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_lub</span> <span class="o">(</span><span class="n">X</span> <span class="bp">+</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- `X + Y := { z | ∃ x y, x ∈ X ∧ y ∈ Y ∧ x + y = z }`</span>
<span class="bp">⟨λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hxy</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hz</span> <span class="k">in</span>
  <span class="n">hxy</span> <span class="bp">▸</span> <span class="n">add_le_add</span> <span class="o">(</span><span class="n">h0</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hy</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span> <span class="n">add_le_of_le_sub_left</span> <span class="err">$</span> <span class="n">h1</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">le_sub</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">h0</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">le_sub_iff_add_le</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span>
  <span class="n">hr</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206335061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206335061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206335061">(Aug 08 2020 at 06:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> deja vu?</p>



<a name="206336348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336348">(Aug 08 2020 at 07:19)</a>:</h4>
<p>Do you know why I get <code>type mismatch at application</code> for the  <code>exists.elim s2</code>?</p>



<a name="206336352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336352">(Aug 08 2020 at 07:19)</a>:</h4>
<p>don't use <code>exists.elim</code></p>



<a name="206336353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336353">(Aug 08 2020 at 07:19)</a>:</h4>
<p>use <code>let</code></p>



<a name="206336453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336453">(Aug 08 2020 at 07:22)</a>:</h4>
<p>That works on existential elimination?</p>



<a name="206336460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336460">(Aug 08 2020 at 07:23)</a>:</h4>
<p>Is there an example somewhere?</p>



<a name="206336690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336690">(Aug 08 2020 at 07:32)</a>:</h4>
<p>Another more natural choice is to use <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#obtain">tactic#obtain</a> , example:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">lint</span>

<span class="kn">open</span> <span class="n">int</span>

<span class="kn">theorem</span> <span class="n">le</span><span class="bp">.</span><span class="n">antisymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="k">assume</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">),</span>
<span class="k">obtain</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">Hn</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">H₁</span><span class="o">,</span>
<span class="k">obtain</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">Hm</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">H₂</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₃</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">+</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>                     <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">of_nat_eq_coe</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>                       <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_assoc</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">m</span>                           <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">Hn</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span>                               <span class="o">:</span> <span class="n">Hm</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span>                           <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_zero</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₄</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">of_nat</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">add_left_cancel</span> <span class="n">H₃</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₅</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>                 <span class="k">from</span> <span class="n">of_nat</span><span class="bp">.</span><span class="n">inj</span> <span class="n">H₄</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h₆</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>                     <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">eq_zero_of_add_eq_zero_right</span> <span class="n">H₅</span><span class="o">,</span>
<span class="k">show</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span>    <span class="o">:</span> <span class="k">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">]</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">n</span>    <span class="o">:</span> <span class="k">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">h₆</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_zero</span><span class="o">]</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span>        <span class="o">:</span> <span class="n">Hn</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206336844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336844">(Aug 08 2020 at 07:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206336460">said</a>:</p>
<blockquote>
<p>Is there an example somewhere?</p>
</blockquote>
<p>look at my proof</p>



<a name="206336847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336847">(Aug 08 2020 at 07:36)</a>:</h4>
<p>the <code>let</code> I used is the existential elimination</p>



<a name="206338859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206338859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206338859">(Aug 08 2020 at 08:42)</a>:</h4>
<p>Bit higher level than Kenny's:</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">intros</span> <span class="n">z</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">H</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">linarith</span> <span class="o">[</span><span class="n">h0</span><span class="bp">.</span><span class="n">left</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">h1</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span> <span class="n">hy</span><span class="o">],</span>
</code></pre></div>



<a name="206356861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206356861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206356861">(Aug 08 2020 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206335061">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> deja vu?</p>
</blockquote>
<p>?</p>



<a name="206357641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206357641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206357641">(Aug 08 2020 at 18:01)</a>:</h4>
<p>Is there a way to make it more verbose? Something like <code>obtain (x : ℝ, hx : x ∈ X, y : ℝ, hy : y ∈ Y, h : z = x + y) from a1,</code>?</p>



<a name="206362001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362001">(Aug 08 2020 at 20:02)</a>:</h4>
<p>Something like</p>
<div class="codehilite"><pre><span></span><code><span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
</code></pre></div>


<p>(untested)</p>



<a name="206362169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362169">(Aug 08 2020 at 20:07)</a>:</h4>
<p>Sorry, I was thinking more along the lines of showing explicitly what <code>hx</code>, <code>hy</code>,  and <code>h</code> get assigned to in the <code>obtain</code> statement.</p>



<a name="206362533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362533">(Aug 08 2020 at 20:17)</a>:</h4>
<p>Yeah, I don't think that's possible</p>



<a name="206362585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362585">(Aug 08 2020 at 20:18)</a>:</h4>
<p>:(</p>



<a name="206362779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362779">(Aug 08 2020 at 20:24)</a>:</h4>
<p>I might prefer the <code>exists.elim</code> then, as it shows more of the details in the proof itself. I'm still not sure why I get <code>type mismatch at application</code> for the <code>exists.elim s2</code> though.</p>



<a name="206362918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362918">(Aug 08 2020 at 20:29)</a>:</h4>
<p>That's definitely possible</p>



<a name="206362974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362974">(Aug 08 2020 at 20:30)</a>:</h4>
<p>use <code>rcases a_eq : a1 with  ⟨x, hx, y, hy, h⟩</code></p>



<a name="206362979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362979">(Aug 08 2020 at 20:30)</a>:</h4>
<p>I don't know if <code>obtain</code> has a similar syntax</p>



<a name="206363057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363057">(Aug 08 2020 at 20:34)</a>:</h4>
<p>Sorry, I'm not sure I see the difference. I still need to go to the other window to read what x, hx, etc. are?</p>



<a name="206363096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363096">(Aug 08 2020 at 20:34)</a>:</h4>
<p>what's the mwe?</p>



<a name="206363109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363109">(Aug 08 2020 at 20:35)</a>:</h4>
<p>Oh I misunderstood your question</p>



<a name="206363160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363160">(Aug 08 2020 at 20:36)</a>:</h4>
<p>I've been planning to add support for type ascriptions in rcases/obtain, so that you could write</p>
<div class="codehilite"><pre><span></span><code><span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">⟩</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
</code></pre></div>



<a name="206363170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363170">(Aug 08 2020 at 20:37)</a>:</h4>
<p>Yes, that is what I meant. That would be great.</p>



<a name="206363181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363181">(Aug 08 2020 at 20:37)</a>:</h4>
<p>you might have to put parentheses around the type ascriptions, for consistency with other uses of type ascription</p>



<a name="206363229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363229">(Aug 08 2020 at 20:38)</a>:</h4>
<p>it also might interact with <code>|</code> in a weird way if you have a notation that uses <code>|</code></p>



<a name="206363550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363550">(Aug 08 2020 at 20:49)</a>:</h4>
<p>I don't mind using exists.elim, but I think I am applying it to the double exists wrong?</p>



<a name="206364293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206364293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206364293">(Aug 08 2020 at 21:14)</a>:</h4>
<p>I think I got it!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pointwise</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≥</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">is_lub_add</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">X</span> <span class="bp">+</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">+</span> <span class="n">Y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">),</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">s1</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">x&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span> <span class="bp">∧</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
      <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">a2</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">y&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span> <span class="bp">∧</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">X</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h0</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">x&#39;</span> <span class="n">a3</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">s4</span> <span class="n">y&#39;</span> <span class="n">a3</span><span class="bp">.</span><span class="n">right</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span>
      <span class="o">)</span>
  <span class="o">)</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206366973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206366973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206366973">(Aug 08 2020 at 22:32)</a>:</h4>
<p>Where does this error come from?<br>
<a href="/user_uploads/3121/JpWWXTYgBcdKd0dmile1ToAF/Screenshot-from-2020-08-08-15-31-29.png">Screenshot-from-2020-08-08-15-31-29.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/JpWWXTYgBcdKd0dmile1ToAF/Screenshot-from-2020-08-08-15-31-29.png" title="Screenshot-from-2020-08-08-15-31-29.png"><img src="/user_uploads/3121/JpWWXTYgBcdKd0dmile1ToAF/Screenshot-from-2020-08-08-15-31-29.png"></a></div>



<a name="206366986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206366986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206366986">(Aug 08 2020 at 22:33)</a>:</h4>
<p>Oh</p>



<a name="206366993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206366993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206366993">(Aug 08 2020 at 22:33)</a>:</h4>
<p>I got this one quite a lot, I was about to ask the same thing</p>



<a name="206367067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367067">(Aug 08 2020 at 22:34)</a>:</h4>
<p>Well, I know why this happens : the hypothesis <code>is_ub (X+Y) r</code> in the implication is implicitly named <code>a</code>, shadowing the <code>a</code> you want</p>



<a name="206367153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367153">(Aug 08 2020 at 22:37)</a>:</h4>
<p>But the only way to avoid this I know is writing the implication as a forall, namely <code>\for (h : is_ub (X+Y) r), ...</code>. This way you can name the hypothesis so no problem of shadowing. But this is quite ugly, so maybe there's a better solution ?</p>



<a name="206367307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367307">(Aug 08 2020 at 22:41)</a>:</h4>
<p>How are you able to tell that the hypothesis is implicitly named <code>a</code>?</p>



<a name="206367378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367378">(Aug 08 2020 at 22:43)</a>:</h4>
<p>By reading the error message <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> The type of <code>a</code> is exactly the left side of your implication, which means precisely that <code>a</code> is a proof of <code>is_ub (X+Y) r</code></p>



<a name="206367435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367435">(Aug 08 2020 at 22:44)</a>:</h4>
<p>I see. Well, changing <code>a</code> and <code>b</code> to <code>t0</code> and <code>t1</code> fixes it. That works I guess.</p>



<a name="206367450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367450">(Aug 08 2020 at 22:45)</a>:</h4>
<p>Thank you.</p>



<a name="206367538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367538">(Aug 08 2020 at 22:48)</a>:</h4>
<p>No problem ! It would be nice for this to be fixed at some point anyway, but maybe it's harder than I imagine</p>



<a name="206379893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206379893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206379893">(Aug 09 2020 at 05:24)</a>:</h4>
<p>just use <code>guard_hyp</code></p>



<a name="206380029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206380029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206380029">(Aug 09 2020 at 05:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206363160">said</a>:</p>
<blockquote>
<p>I've been planning to add support for type ascriptions in rcases/obtain, so that you could write</p>
<div class="codehilite"><pre><span></span><code><span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">⟩</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
</code></pre></div>


</blockquote>
<p>This works now, as of <a href="https://github.com/leanprover-community/mathlib/issues/3730">#3730</a>, which is a significant rewrite of <code>rcases</code> to support some more flexible pattern syntax. You can now use parentheses like <code>(a | b) | c</code> in patterns instead of the previous strict alternation of and/or</p>



<a name="206388310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206388310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206388310">(Aug 09 2020 at 10:06)</a>:</h4>
<p>Build is failing.</p>



<a name="206409589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206409589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206409589">(Aug 09 2020 at 20:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206379893">said</a>:</p>
<blockquote>
<p>just use <code>guard_hyp</code></p>
</blockquote>
<p>Could you explain a bit more what you meant ?</p>



<a name="206428801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206428801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206428801">(Aug 10 2020 at 05:14)</a>:</h4>
<p>you can use <code>guard_hyp</code> to assert that a hypothesis has a certain type</p>



<a name="206428809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206428809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206428809">(Aug 10 2020 at 05:15)</a>:</h4>
<p>so if you want to assert that <code>hx</code> has type <code>x \in X</code> then just use <code>guard_hyp</code></p>



<a name="209937624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209937624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209937624">(Sep 13 2020 at 16:02)</a>:</h4>
<p>I'm trying to define a partition using a list. Is this a good definition?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_head</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">head&#39;</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">last&#39;</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span>   <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">real</span><span class="bp">.</span><span class="n">le</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>


<p>I think the <code>x_head</code> and <code>x_last</code> constructors ensure that the list is not empty?<br>
Using that I am trying to define the norm. I looked at using <code>list.foldr</code> for taking the max, but it requires an initial accumulator value that I would like to avoid.</p>



<a name="209937832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209937832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209937832">(Sep 13 2020 at 16:07)</a>:</h4>
<p>I think maybe I need something like the <code>foldr1</code> function in Haskell.</p>



<a name="209941127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941127">(Sep 13 2020 at 17:30)</a>:</h4>
<p>Is there a way to have an option to show the types in the mathlib generated documentation?</p>



<a name="209941319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941319">(Sep 13 2020 at 17:35)</a>:</h4>
<p>For example that <code>l</code> is a list in the definition of a vector?<br>
<a href="https://leanprover-community.github.io/mathlib_docs/core/data/vector.html#vector">https://leanprover-community.github.io/mathlib_docs/core/data/vector.html#vector</a></p>



<a name="209941381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941381">(Sep 13 2020 at 17:36)</a>:</h4>
<p>If you click on "source" you see <code>def vector (α : Type u) (n : ℕ) := { l : list α // l.length = n }</code> . Does this answer your question?</p>



<a name="209941401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941401">(Sep 13 2020 at 17:37)</a>:</h4>
<p>I was being lazy and thought it might be nice to have an option to avoid that :)</p>



<a name="209941477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941477">(Sep 13 2020 at 17:39)</a>:</h4>
<p>Sorry</p>



<a name="209941485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941485">(Sep 13 2020 at 17:40)</a>:</h4>
<p><code>#print vector</code> within a Lean file should also tell you everything about it</p>



<a name="209941548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941548">(Sep 13 2020 at 17:41)</a>:</h4>
<p>Even more work :)</p>



<a name="209941558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941558">(Sep 13 2020 at 17:41)</a>:</h4>
<p>If you hover over <code>.length</code> in <code>l.length</code>, you can see that the URL ends in <code>list.length</code> which is a clue. But feel free to open an issue <a href="https://github.com/leanprover-community/doc-gen/issues">here</a>.</p>



<a name="209941574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941574">(Sep 13 2020 at 17:41)</a>:</h4>
<p>Ok. Thank you.</p>



<a name="209942003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209942003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209942003">(Sep 13 2020 at 17:52)</a>:</h4>
<p>Added: <a href="https://github.com/leanprover-community/doc-gen/issues/63">https://github.com/leanprover-community/doc-gen/issues/63</a></p>



<a name="209944740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944740">(Sep 13 2020 at 18:56)</a>:</h4>
<p>If a vector is based on a list, how do you use the functions defined for lists on it? Do you have to cast it to a list first?</p>



<a name="209944750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944750">(Sep 13 2020 at 18:57)</a>:</h4>
<p>A vector is a pair consisting of a list and a proof.</p>



<a name="209944827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944827">(Sep 13 2020 at 18:58)</a>:</h4>
<p><code> vector α n = {l // l.length = n}</code> defines a list and a proof?</p>



<a name="209944839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944839">(Sep 13 2020 at 18:59)</a>:</h4>
<p>The proof comes from the type somehow?</p>



<a name="209944914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944914">(Sep 13 2020 at 19:00)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html?highlight=subtype#inductively-defined-propositions">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html?highlight=subtype#inductively-defined-propositions</a></p>



<a name="209944929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944929">(Sep 13 2020 at 19:00)</a>:</h4>
<p>the proof comes from the proof which you'll supply that l.length=n when you're making the term. vector is a subtype -- see the link above.</p>



<a name="209946379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209946379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209946379">(Sep 13 2020 at 19:34)</a>:</h4>
<p>So I should be able to get at the list by using <code>.val</code>?</p>



<a name="209946598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209946598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209946598">(Sep 13 2020 at 19:41)</a>:</h4>
<p>Got it. Thank you.</p>



<a name="209947869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209947869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209947869">(Sep 13 2020 at 20:14)</a>:</h4>
<p>Is there a function defined similar to <code>vector.head</code> for getting the last element of the vector where you don't have to worry about the vector being <code>nil</code>?</p>



<a name="209948965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209948965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209948965">(Sep 13 2020 at 20:48)</a>:</h4>
<p>I'm trying to make something like this work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">vector</span><span class="bp">.</span><span class="n">head</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">vector</span><span class="bp">.</span><span class="n">last</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">real</span><span class="bp">.</span><span class="n">le</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℝ</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">y</span><span class="bp">.</span><span class="n">at</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">Icc</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">at</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">at</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span>
</code></pre></div>



<a name="209950071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950071">(Sep 13 2020 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/209947869">said</a>:</p>
<blockquote>
<p>Is there a function defined similar to <code>vector.head</code> for getting the last element of the vector where you don't have to worry about the vector being <code>nil</code>?</p>
</blockquote>
<p>I don't know the vector or list API's at all but why don't you just write the precise function you want and then ask whether this precise function is already there?</p>



<a name="209950089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950089">(Sep 13 2020 at 21:21)</a>:</h4>
<p>I can write the type, but I'm having trouble defining it.</p>



<a name="209950151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950151">(Sep 13 2020 at 21:23)</a>:</h4>
<p>The same as this but returns the last element instead of the first:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">head</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="o">[],</span>    <span class="n">h</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="n">a</span>
</code></pre></div>



<a name="209950326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950326">(Sep 13 2020 at 21:28)</a>:</h4>
<p>It doesn't seem to exist already.  One way is to define it with <code>vector.nth</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">last</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">v</span><span class="bp">.</span><span class="n">nth</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">less_than_or_equal</span><span class="bp">.</span><span class="n">refl</span><span class="bp">⟩</span>
</code></pre></div>



<a name="209950378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950378">(Sep 13 2020 at 21:30)</a>:</h4>
<p>Nice. Thank you.</p>



<a name="209950383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950383">(Sep 13 2020 at 21:30)</a>:</h4>
<p>Another is in terms of <code>list.last</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">last</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="o">[],</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span> <span class="bp">::</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">::</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
</code></pre></div>



<a name="209950397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950397">(Sep 13 2020 at 21:31)</a>:</h4>
<p>In the first, should n be n + 1 in the body?</p>



<a name="209950455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950455">(Sep 13 2020 at 21:33)</a>:</h4>
<p>I don't think so, since if you have a vector of length n+1, since it's zero-indexed the last element will be indexed by n.</p>



<a name="209950462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950462">(Sep 13 2020 at 21:33)</a>:</h4>
<p>Oh. Right.</p>



<a name="209950589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950589">(Sep 13 2020 at 21:36)</a>:</h4>
<p>I don't know how heavily you're invested in <code>vector</code>, but all of these things (I think) are already in the API for <code>fin n</code>, i.e. representations of <code>n</code>-tuples as <code>fin n \to A</code>.</p>



<a name="209950602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950602">(Sep 13 2020 at 21:37)</a>:</h4>
<p>And data.matrix.notation has nice notation for those</p>



<a name="209950733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950733">(Sep 13 2020 at 21:40)</a>:</h4>
<p>Not completely invested. I just figured that since there is a lot of beginner documentation and tutorials on lists and vectors that I would understand it better by going with that.</p>



<a name="209950769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950769">(Sep 13 2020 at 21:41)</a>:</h4>
<p>For example I don't understand <code>(finset.univ : finset (fin P.n)).sup (λ j, (P.x j.cast_succ - P.x j.succ))</code></p>



<a name="209950824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950824">(Sep 13 2020 at 21:43)</a>:</h4>
<p>Where's that from?</p>



<a name="209950877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950877">(Sep 13 2020 at 21:44)</a>:</h4>
<p>Much earlier in the thread.</p>



<a name="209950939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950939">(Sep 13 2020 at 21:46)</a>:</h4>
<p>Oh, I see. In the link for the lean web editor? Note the commented out notation there :)</p>



<a name="209950945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950945">(Sep 13 2020 at 21:46)</a>:</h4>
<p>That should be approximately familiar mathematical notation.</p>



<a name="209951021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951021">(Sep 13 2020 at 21:48)</a>:</h4>
<p>Yeah. I'm going to have to prove things about it though.</p>



<a name="209951036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951036">(Sep 13 2020 at 21:49)</a>:</h4>
<p>This is another reason to use <code>fin n</code>if the API is more developed.</p>



<a name="209951092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951092">(Sep 13 2020 at 21:50)</a>:</h4>
<p>True.</p>



<a name="209951100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951100">(Sep 13 2020 at 21:51)</a>:</h4>
<p>If I understand the API :)</p>



<a name="209951165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951165">(Sep 13 2020 at 21:53)</a>:</h4>
<p>I'll probably move on to it at some point.</p>



<a name="209951440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951440">(Sep 13 2020 at 22:00)</a>:</h4>
<p>What is the * after Type by the way?</p>



<a name="209951447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951447">(Sep 13 2020 at 22:00)</a>:</h4>
<p>It tells lean to go and figure out the universe variable.</p>



<a name="209951448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951448">(Sep 13 2020 at 22:00)</a>:</h4>
<p>Ah.</p>



<a name="209952950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209952950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209952950">(Sep 13 2020 at 22:40)</a>:</h4>
<p>The finset.univ line says that, for all values of (fin P.n), that is, from 0 to n-1.</p>



<a name="209952971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209952971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209952971">(Sep 13 2020 at 22:41)</a>:</h4>
<p>Then the supremum of the set of all those values, under the map taking each such value j to P.x[j + 1] - P.x[j]</p>



<a name="209952974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209952974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209952974">(Sep 13 2020 at 22:41)</a>:</h4>
<p>In python list accession syntax</p>



<a name="209953096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209953096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209953096">(Sep 13 2020 at 22:44)</a>:</h4>
<p>finset.univ means a finset (a finite set) of all the terms for a given type</p>



<a name="209962399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962399">(Sep 14 2020 at 03:30)</a>:</h4>
<p>For my own understanding, this seemed to work? Is this right?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>


<span class="kn">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
<span class="c1">-- a : element to prepend, n : length of vector to prepend to, v : vector to prepend to</span>
<span class="c1">-- note the use of n in the type of v</span>


<span class="n">def</span> <span class="n">first</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>


<span class="n">def</span> <span class="n">v1</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span>
<span class="n">def</span> <span class="n">v2</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">v1</span>
<span class="n">def</span> <span class="n">v3</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="n">v2</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">first</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">v2</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">first</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="n">v3</span>


<span class="n">def</span> <span class="n">last</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">n</span> <span class="n">v</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="209962464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962464">(Sep 14 2020 at 03:32)</a>:</h4>
<p><code>first</code> and <code>last</code> didn't seem to need a proof that the vector wasn't empty like the ones in the library, so I'm a little unsure. I am guessing that is because of the way that <code>vector</code> was defined?</p>



<a name="209962477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962477">(Sep 14 2020 at 03:33)</a>:</h4>
<p>Functionally I think this is equivalent though?</p>



<a name="209962680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962680">(Sep 14 2020 at 03:39)</a>:</h4>
<p>The proof that it isn't empty in your definition is that the patterns you're matching on require a vector of length (n + 1)</p>



<a name="209962740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962740">(Sep 14 2020 at 03:41)</a>:</h4>
<p>If you want to play more with these definitions, you could make se arguments implicit, like making the length argument to cons or first or last implicit. Since it can be inferred from the type of vector.</p>



<a name="209962746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962746">(Sep 14 2020 at 03:41)</a>:</h4>
<p>Also, look into Pi types, which are type level foralls</p>



<a name="209962855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962855">(Sep 14 2020 at 03:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/209962680">said</a>:</p>
<blockquote>
<p>The proof that it isn't empty in your definition is that the patterns you're matching on require a vector of length (n + 1)</p>
</blockquote>
<p>That is what I was guessing.</p>



<a name="209962858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962858">(Sep 14 2020 at 03:44)</a>:</h4>
<p>Thank you.</p>



<a name="210618445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210618445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210618445">(Sep 19 2020 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/209952950">said</a>:</p>
<blockquote>
<p>The finset.univ line says that, for all values of (fin P.n), that is, from 0 to n-1.</p>
</blockquote>
<p>I'm sorry, I'm still not sure I get this. Maybe if the steps were broken apart it would be easier to see? How would it look if we first took the differences and then the sup? What would be the least abstract way to build this up from just the definition of fin?</p>



<a name="210619916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210619916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210619916">(Sep 19 2020 at 15:13)</a>:</h4>
<p><code>fin n</code> is the subtype of <code>nat</code> of nats which are less than <code>n</code>.<br>
<code>finset (fin n)</code> is the type of all finite sets (unordered lists with no duplicates) whose members are all from <code>fin n</code>.<br>
<code>univ</code> (or <code>finset.univ</code> if the namespace isn't open) is the term of <code>finset X</code> containing all terms of type <code>X</code> when <code>X</code> is a type with only finitely many terms (which <code>fin n</code> is).<br>
If you just type <code>#check finset.univ</code> lean doesn't know what you want a finset of so <code>(finset.univ : finset (fin n))</code> is the term representing the set of all the terms of <code>fin n</code>.<br>
<code>finset.sup</code> then takes the supremum of the function <code>(λ j, (P.x j.cast_succ - P.x j.succ))</code> over the specified set, with the dot notation so it comes after the set, in this case <code>univ</code>.</p>



<a name="210620038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620038">(Sep 19 2020 at 15:16)</a>:</h4>
<p>I think this code is taking the differences first then the sup already. The <code>(λ j, (P.x j.cast_succ - P.x j.succ))</code> function is applied to each term of <code>fin P.n</code> and the sup is taken of those values as it goes.</p>



<a name="210620251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620251">(Sep 19 2020 at 15:21)</a>:</h4>
<p>So <code>finset (fin 3)</code> has the terms <code>[0, 1, 2], [0, 2, 1], [1, 0, 2]</code> etc.?</p>



<a name="210620346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620346">(Sep 19 2020 at 15:23)</a>:</h4>
<p>By unordered I mean the ordering doesn't matter, so its<br>
<code>{}, {0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}</code><br>
and the last one there is <code>univ</code>.</p>



<a name="210620567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620567">(Sep 19 2020 at 15:29)</a>:</h4>
<p>I see.<br>
What happens if the set has only one element? If I'm reading the definition of partition correctly, I think it allows that?</p>



<a name="210621960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210621960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210621960">(Sep 19 2020 at 16:01)</a>:</h4>
<p>It looks like it is using some kind of fold. Maybe it defaults to some value?</p>



<a name="210623422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210623422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210623422">(Sep 19 2020 at 16:35)</a>:</h4>
<p>If the partition has 1 element then <code>n = 0</code> as it is a map from <code>fin (n + 1) \to \R\ge0</code> so I think in that case its the <code>sup</code> over the empty set, which defaults to the infimum of the whole target. Which version of the code are you using, it changed a bit throughout this thread.</p>



<a name="210623971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210623971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210623971">(Sep 19 2020 at 16:46)</a>:</h4>
<p>I was thinking that since it is taking adjacent differences there would be a problem with the set of only one element, since that element does not have an adjacent element.</p>



<a name="210624063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624063">(Sep 19 2020 at 16:48)</a>:</h4>
<p>I had been looking at the following code, but now it gives an error next to the .sup:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="c1">-- := ⨆ i : fin P.n, P.x i.succ - P.x i.cast_succ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="kn">end</span> <span class="n">partition</span>
</code></pre></div>



<a name="210624343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624343">(Sep 19 2020 at 16:55)</a>:</h4>
<p>Also, why is it <code>(finset.univ : finset (fin P.n))</code> instead of <code>(finset.univ (finset (fin P.n)))</code>?</p>



<a name="210624473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624473">(Sep 19 2020 at 16:58)</a>:</h4>
<p>the colon is specifying the type of the term on the left. <code>finset.univ</code> takes no explicit arguments, if you type <code>#check finset.univ</code> you should see <code>finset.univ : finset ?M_1</code>, so there are no arguments to be filled in, but there is a metavariable in the type, which means that lean doesn't know what sort of  finset the term <code> finset.univ</code>  is without extra hints, which is what the <code>: </code> is doing, telling lean what type you expect it to be.</p>



<a name="210624540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624540">(Sep 19 2020 at 17:00)</a>:</h4>
<p>You could instead tell lean you want to specify implicit arguments as arguments directly,  by using <code>@finset.univ</code>, the type of this is now  <code>finset.univ : Π {α : Type u_1} [_inst_1 : fintype α], finset α</code>, which we see has 2 arguments, the type and the fact it is a fintype, so we could write instead, <code>(@finset.univ (fin P.n)).sup ...</code></p>



<a name="210624635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624635">(Sep 19 2020 at 17:02)</a>:</h4>
<p>I see. Thank you.</p>



<a name="210624636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624636">(Sep 19 2020 at 17:02)</a>:</h4>
<p>The error next to the sup is discussed somewhere above in the thread, but its basically the issue you are worried about, if there is only one thing in the partition lean want to assign some default value to the norm, as its a sup over an empty set, but it doesn't have a sensible choice, as <code>\R</code> has no minimal element. Thats why in the version I gave a while ago I switched it to <code> \R\ge0</code>, which has a minimal element!</p>



<a name="210624713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624713">(Sep 19 2020 at 17:04)</a>:</h4>
<p>When the partition has <code>n+1</code> points in it, the list of things we take the sup over only has <code>n</code>.</p>



<a name="210624803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624803">(Sep 19 2020 at 17:06)</a>:</h4>
<p>I see.</p>



{% endraw %}

<hr><p>Last updated: Oct 06 2020 at 10:10 UTC</p>